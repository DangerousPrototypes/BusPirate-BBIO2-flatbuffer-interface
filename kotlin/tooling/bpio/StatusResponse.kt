// automatically generated by the FlatBuffers compiler, do not modify

package bpio

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

@Suppress("unused")
class StatusResponse : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : StatusResponse {
        __init(_i, _bb)
        return this
    }
    val error : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val errorAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun errorInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    val hardwareVersionMajor : UByte
        get() {
            val o = __offset(6)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val hardwareVersionMinor : UByte
        get() {
            val o = __offset(8)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val firmwareVersionMajor : UByte
        get() {
            val o = __offset(10)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val firmwareVersionMinor : UByte
        get() {
            val o = __offset(12)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val firmwareGitHash : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val firmwareGitHashAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun firmwareGitHashInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    val firmwareDate : String?
        get() {
            val o = __offset(16)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val firmwareDateAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 1)
    fun firmwareDateInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)
    fun modesAvailable(j: Int) : String? {
        val o = __offset(18)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val modesAvailableLength : Int
        get() {
            val o = __offset(18); return if (o != 0) __vector_len(o) else 0
        }
    val modeCurrent : String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val modeCurrentAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun modeCurrentInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    fun modePinLabels(j: Int) : String? {
        val o = __offset(22)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val modePinLabelsLength : Int
        get() {
            val o = __offset(22); return if (o != 0) __vector_len(o) else 0
        }
    val modeBitorderMsb : Boolean
        get() {
            val o = __offset(24)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    val psuEnabled : Boolean
        get() {
            val o = __offset(26)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    val psuSetMv : UInt
        get() {
            val o = __offset(28)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    val psuSetMa : UInt
        get() {
            val o = __offset(30)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    val psuMeasuredMv : UInt
        get() {
            val o = __offset(32)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    val psuMeasuredMa : UInt
        get() {
            val o = __offset(34)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    val psuCurrentError : Boolean
        get() {
            val o = __offset(36)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    val pullupEnabled : Boolean
        get() {
            val o = __offset(38)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    val pullxConfig : UInt
        get() {
            val o = __offset(40)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    fun adcMv(j: Int) : UInt {
        val o = __offset(42)
        return if (o != 0) {
            bb.getInt(__vector(o) + j * 4).toUInt()
        } else {
            0u
        }
    }
    val adcMvLength : Int
        get() {
            val o = __offset(42); return if (o != 0) __vector_len(o) else 0
        }
    val adcMvAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(42, 4)
    fun adcMvInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 42, 4)
    val ioDirection : UByte
        get() {
            val o = __offset(44)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val ioValue : UByte
        get() {
            val o = __offset(46)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val diskSizeMb : Float
        get() {
            val o = __offset(48)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val diskUsedMb : Float
        get() {
            val o = __offset(50)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val ledCount : UByte
        get() {
            val o = __offset(52)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()
        fun getRootAsStatusResponse(_bb: ByteBuffer): StatusResponse = getRootAsStatusResponse(_bb, StatusResponse())
        fun getRootAsStatusResponse(_bb: ByteBuffer, obj: StatusResponse): StatusResponse {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createStatusResponse(builder: FlatBufferBuilder, errorOffset: Int, hardwareVersionMajor: UByte, hardwareVersionMinor: UByte, firmwareVersionMajor: UByte, firmwareVersionMinor: UByte, firmwareGitHashOffset: Int, firmwareDateOffset: Int, modesAvailableOffset: Int, modeCurrentOffset: Int, modePinLabelsOffset: Int, modeBitorderMsb: Boolean, psuEnabled: Boolean, psuSetMv: UInt, psuSetMa: UInt, psuMeasuredMv: UInt, psuMeasuredMa: UInt, psuCurrentError: Boolean, pullupEnabled: Boolean, pullxConfig: UInt, adcMvOffset: Int, ioDirection: UByte, ioValue: UByte, diskSizeMb: Float, diskUsedMb: Float, ledCount: UByte) : Int {
            builder.startTable(25)
            addDiskUsedMb(builder, diskUsedMb)
            addDiskSizeMb(builder, diskSizeMb)
            addAdcMv(builder, adcMvOffset)
            addPullxConfig(builder, pullxConfig)
            addPsuMeasuredMa(builder, psuMeasuredMa)
            addPsuMeasuredMv(builder, psuMeasuredMv)
            addPsuSetMa(builder, psuSetMa)
            addPsuSetMv(builder, psuSetMv)
            addModePinLabels(builder, modePinLabelsOffset)
            addModeCurrent(builder, modeCurrentOffset)
            addModesAvailable(builder, modesAvailableOffset)
            addFirmwareDate(builder, firmwareDateOffset)
            addFirmwareGitHash(builder, firmwareGitHashOffset)
            addError(builder, errorOffset)
            addLedCount(builder, ledCount)
            addIoValue(builder, ioValue)
            addIoDirection(builder, ioDirection)
            addPullupEnabled(builder, pullupEnabled)
            addPsuCurrentError(builder, psuCurrentError)
            addPsuEnabled(builder, psuEnabled)
            addModeBitorderMsb(builder, modeBitorderMsb)
            addFirmwareVersionMinor(builder, firmwareVersionMinor)
            addFirmwareVersionMajor(builder, firmwareVersionMajor)
            addHardwareVersionMinor(builder, hardwareVersionMinor)
            addHardwareVersionMajor(builder, hardwareVersionMajor)
            return endStatusResponse(builder)
        }
        fun startStatusResponse(builder: FlatBufferBuilder) = builder.startTable(25)
        fun addError(builder: FlatBufferBuilder, error: Int) = builder.addOffset(0, error, 0)
        fun addHardwareVersionMajor(builder: FlatBufferBuilder, hardwareVersionMajor: UByte) = builder.addByte(1, hardwareVersionMajor.toByte(), 0)
        fun addHardwareVersionMinor(builder: FlatBufferBuilder, hardwareVersionMinor: UByte) = builder.addByte(2, hardwareVersionMinor.toByte(), 0)
        fun addFirmwareVersionMajor(builder: FlatBufferBuilder, firmwareVersionMajor: UByte) = builder.addByte(3, firmwareVersionMajor.toByte(), 0)
        fun addFirmwareVersionMinor(builder: FlatBufferBuilder, firmwareVersionMinor: UByte) = builder.addByte(4, firmwareVersionMinor.toByte(), 0)
        fun addFirmwareGitHash(builder: FlatBufferBuilder, firmwareGitHash: Int) = builder.addOffset(5, firmwareGitHash, 0)
        fun addFirmwareDate(builder: FlatBufferBuilder, firmwareDate: Int) = builder.addOffset(6, firmwareDate, 0)
        fun addModesAvailable(builder: FlatBufferBuilder, modesAvailable: Int) = builder.addOffset(7, modesAvailable, 0)
        fun createModesAvailableVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startModesAvailableVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addModeCurrent(builder: FlatBufferBuilder, modeCurrent: Int) = builder.addOffset(8, modeCurrent, 0)
        fun addModePinLabels(builder: FlatBufferBuilder, modePinLabels: Int) = builder.addOffset(9, modePinLabels, 0)
        fun createModePinLabelsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startModePinLabelsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addModeBitorderMsb(builder: FlatBufferBuilder, modeBitorderMsb: Boolean) = builder.addBoolean(10, modeBitorderMsb, false)
        fun addPsuEnabled(builder: FlatBufferBuilder, psuEnabled: Boolean) = builder.addBoolean(11, psuEnabled, false)
        fun addPsuSetMv(builder: FlatBufferBuilder, psuSetMv: UInt) = builder.addInt(12, psuSetMv.toInt(), 0)
        fun addPsuSetMa(builder: FlatBufferBuilder, psuSetMa: UInt) = builder.addInt(13, psuSetMa.toInt(), 0)
        fun addPsuMeasuredMv(builder: FlatBufferBuilder, psuMeasuredMv: UInt) = builder.addInt(14, psuMeasuredMv.toInt(), 0)
        fun addPsuMeasuredMa(builder: FlatBufferBuilder, psuMeasuredMa: UInt) = builder.addInt(15, psuMeasuredMa.toInt(), 0)
        fun addPsuCurrentError(builder: FlatBufferBuilder, psuCurrentError: Boolean) = builder.addBoolean(16, psuCurrentError, false)
        fun addPullupEnabled(builder: FlatBufferBuilder, pullupEnabled: Boolean) = builder.addBoolean(17, pullupEnabled, false)
        fun addPullxConfig(builder: FlatBufferBuilder, pullxConfig: UInt) = builder.addInt(18, pullxConfig.toInt(), 0)
        fun addAdcMv(builder: FlatBufferBuilder, adcMv: Int) = builder.addOffset(19, adcMv, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createAdcMvVector(builder: FlatBufferBuilder, data: UIntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addInt(data[i].toInt())
            }
            return builder.endVector()
        }
        fun startAdcMvVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addIoDirection(builder: FlatBufferBuilder, ioDirection: UByte) = builder.addByte(20, ioDirection.toByte(), 0)
        fun addIoValue(builder: FlatBufferBuilder, ioValue: UByte) = builder.addByte(21, ioValue.toByte(), 0)
        fun addDiskSizeMb(builder: FlatBufferBuilder, diskSizeMb: Float) = builder.addFloat(22, diskSizeMb, 0.0)
        fun addDiskUsedMb(builder: FlatBufferBuilder, diskUsedMb: Float) = builder.addFloat(23, diskUsedMb, 0.0)
        fun addLedCount(builder: FlatBufferBuilder, ledCount: UByte) = builder.addByte(24, ledCount.toByte(), 0)
        fun endStatusResponse(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
