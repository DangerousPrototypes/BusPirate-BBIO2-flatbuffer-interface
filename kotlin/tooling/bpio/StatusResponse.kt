// automatically generated by the FlatBuffers compiler, do not modify

package bpio

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

@Suppress("unused")
class StatusResponse : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : StatusResponse {
        __init(_i, _bb)
        return this
    }
    val error : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val errorAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun errorInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    val psuEnabled : Boolean
        get() {
            val o = __offset(6)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    val psuSetMv : UInt
        get() {
            val o = __offset(8)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    val psuSetMa : UInt
        get() {
            val o = __offset(10)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    val psuMeasuredMv : UInt
        get() {
            val o = __offset(12)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    val psuMeasuredMa : UInt
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    val psuCurrentError : Boolean
        get() {
            val o = __offset(16)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    val pullupEnabled : Boolean
        get() {
            val o = __offset(18)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    fun adcMv(j: Int) : UInt {
        val o = __offset(20)
        return if (o != 0) {
            bb.getInt(__vector(o) + j * 4).toUInt()
        } else {
            0u
        }
    }
    val adcMvLength : Int
        get() {
            val o = __offset(20); return if (o != 0) __vector_len(o) else 0
        }
    val adcMvAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 4)
    fun adcMvInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 4)
    val ioDirection : UByte
        get() {
            val o = __offset(22)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val ioValue : UByte
        get() {
            val o = __offset(24)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val diskSizeMb : Float
        get() {
            val o = __offset(26)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val diskUsedMb : Float
        get() {
            val o = __offset(28)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val ledCount : UByte
        get() {
            val o = __offset(30)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val versionFlatbuffersMajor : UByte
        get() {
            val o = __offset(32)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val versionFlatbuffersMinor : UShort
        get() {
            val o = __offset(34)
            return if(o != 0) bb.getShort(o + bb_pos).toUShort() else 0u
        }
    val versionHardwareMajor : UByte
        get() {
            val o = __offset(36)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val versionHardwareMinor : UByte
        get() {
            val o = __offset(38)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val versionFirmwareMajor : UByte
        get() {
            val o = __offset(40)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val versionFirmwareMinor : UByte
        get() {
            val o = __offset(42)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val versionFirmwareGitHash : String?
        get() {
            val o = __offset(44)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val versionFirmwareGitHashAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(44, 1)
    fun versionFirmwareGitHashInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 44, 1)
    val versionFirmwareDate : String?
        get() {
            val o = __offset(46)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val versionFirmwareDateAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(46, 1)
    fun versionFirmwareDateInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 46, 1)
    fun modesAvailable(j: Int) : String? {
        val o = __offset(48)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val modesAvailableLength : Int
        get() {
            val o = __offset(48); return if (o != 0) __vector_len(o) else 0
        }
    val modeCurrent : String?
        get() {
            val o = __offset(50)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val modeCurrentAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(50, 1)
    fun modeCurrentInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 50, 1)
    fun modePinLabels(j: Int) : String? {
        val o = __offset(52)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val modePinLabelsLength : Int
        get() {
            val o = __offset(52); return if (o != 0) __vector_len(o) else 0
        }
    val modeBitorderMsb : Boolean
        get() {
            val o = __offset(54)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    val modeMaxPacketSize : UInt
        get() {
            val o = __offset(56)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    val modeMaxWrite : UInt
        get() {
            val o = __offset(58)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    val modeMaxRead : UInt
        get() {
            val o = __offset(60)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()
        fun getRootAsStatusResponse(_bb: ByteBuffer): StatusResponse = getRootAsStatusResponse(_bb, StatusResponse())
        fun getRootAsStatusResponse(_bb: ByteBuffer, obj: StatusResponse): StatusResponse {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createStatusResponse(builder: FlatBufferBuilder, errorOffset: Int, psuEnabled: Boolean, psuSetMv: UInt, psuSetMa: UInt, psuMeasuredMv: UInt, psuMeasuredMa: UInt, psuCurrentError: Boolean, pullupEnabled: Boolean, adcMvOffset: Int, ioDirection: UByte, ioValue: UByte, diskSizeMb: Float, diskUsedMb: Float, ledCount: UByte, versionFlatbuffersMajor: UByte, versionFlatbuffersMinor: UShort, versionHardwareMajor: UByte, versionHardwareMinor: UByte, versionFirmwareMajor: UByte, versionFirmwareMinor: UByte, versionFirmwareGitHashOffset: Int, versionFirmwareDateOffset: Int, modesAvailableOffset: Int, modeCurrentOffset: Int, modePinLabelsOffset: Int, modeBitorderMsb: Boolean, modeMaxPacketSize: UInt, modeMaxWrite: UInt, modeMaxRead: UInt) : Int {
            builder.startTable(29)
            addModeMaxRead(builder, modeMaxRead)
            addModeMaxWrite(builder, modeMaxWrite)
            addModeMaxPacketSize(builder, modeMaxPacketSize)
            addModePinLabels(builder, modePinLabelsOffset)
            addModeCurrent(builder, modeCurrentOffset)
            addModesAvailable(builder, modesAvailableOffset)
            addVersionFirmwareDate(builder, versionFirmwareDateOffset)
            addVersionFirmwareGitHash(builder, versionFirmwareGitHashOffset)
            addDiskUsedMb(builder, diskUsedMb)
            addDiskSizeMb(builder, diskSizeMb)
            addAdcMv(builder, adcMvOffset)
            addPsuMeasuredMa(builder, psuMeasuredMa)
            addPsuMeasuredMv(builder, psuMeasuredMv)
            addPsuSetMa(builder, psuSetMa)
            addPsuSetMv(builder, psuSetMv)
            addError(builder, errorOffset)
            addVersionFlatbuffersMinor(builder, versionFlatbuffersMinor)
            addModeBitorderMsb(builder, modeBitorderMsb)
            addVersionFirmwareMinor(builder, versionFirmwareMinor)
            addVersionFirmwareMajor(builder, versionFirmwareMajor)
            addVersionHardwareMinor(builder, versionHardwareMinor)
            addVersionHardwareMajor(builder, versionHardwareMajor)
            addVersionFlatbuffersMajor(builder, versionFlatbuffersMajor)
            addLedCount(builder, ledCount)
            addIoValue(builder, ioValue)
            addIoDirection(builder, ioDirection)
            addPullupEnabled(builder, pullupEnabled)
            addPsuCurrentError(builder, psuCurrentError)
            addPsuEnabled(builder, psuEnabled)
            return endStatusResponse(builder)
        }
        fun startStatusResponse(builder: FlatBufferBuilder) = builder.startTable(29)
        fun addError(builder: FlatBufferBuilder, error: Int) = builder.addOffset(0, error, 0)
        fun addPsuEnabled(builder: FlatBufferBuilder, psuEnabled: Boolean) = builder.addBoolean(1, psuEnabled, false)
        fun addPsuSetMv(builder: FlatBufferBuilder, psuSetMv: UInt) = builder.addInt(2, psuSetMv.toInt(), 0)
        fun addPsuSetMa(builder: FlatBufferBuilder, psuSetMa: UInt) = builder.addInt(3, psuSetMa.toInt(), 0)
        fun addPsuMeasuredMv(builder: FlatBufferBuilder, psuMeasuredMv: UInt) = builder.addInt(4, psuMeasuredMv.toInt(), 0)
        fun addPsuMeasuredMa(builder: FlatBufferBuilder, psuMeasuredMa: UInt) = builder.addInt(5, psuMeasuredMa.toInt(), 0)
        fun addPsuCurrentError(builder: FlatBufferBuilder, psuCurrentError: Boolean) = builder.addBoolean(6, psuCurrentError, false)
        fun addPullupEnabled(builder: FlatBufferBuilder, pullupEnabled: Boolean) = builder.addBoolean(7, pullupEnabled, false)
        fun addAdcMv(builder: FlatBufferBuilder, adcMv: Int) = builder.addOffset(8, adcMv, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createAdcMvVector(builder: FlatBufferBuilder, data: UIntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addInt(data[i].toInt())
            }
            return builder.endVector()
        }
        fun startAdcMvVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addIoDirection(builder: FlatBufferBuilder, ioDirection: UByte) = builder.addByte(9, ioDirection.toByte(), 0)
        fun addIoValue(builder: FlatBufferBuilder, ioValue: UByte) = builder.addByte(10, ioValue.toByte(), 0)
        fun addDiskSizeMb(builder: FlatBufferBuilder, diskSizeMb: Float) = builder.addFloat(11, diskSizeMb, 0.0)
        fun addDiskUsedMb(builder: FlatBufferBuilder, diskUsedMb: Float) = builder.addFloat(12, diskUsedMb, 0.0)
        fun addLedCount(builder: FlatBufferBuilder, ledCount: UByte) = builder.addByte(13, ledCount.toByte(), 0)
        fun addVersionFlatbuffersMajor(builder: FlatBufferBuilder, versionFlatbuffersMajor: UByte) = builder.addByte(14, versionFlatbuffersMajor.toByte(), 0)
        fun addVersionFlatbuffersMinor(builder: FlatBufferBuilder, versionFlatbuffersMinor: UShort) = builder.addShort(15, versionFlatbuffersMinor.toShort(), 0)
        fun addVersionHardwareMajor(builder: FlatBufferBuilder, versionHardwareMajor: UByte) = builder.addByte(16, versionHardwareMajor.toByte(), 0)
        fun addVersionHardwareMinor(builder: FlatBufferBuilder, versionHardwareMinor: UByte) = builder.addByte(17, versionHardwareMinor.toByte(), 0)
        fun addVersionFirmwareMajor(builder: FlatBufferBuilder, versionFirmwareMajor: UByte) = builder.addByte(18, versionFirmwareMajor.toByte(), 0)
        fun addVersionFirmwareMinor(builder: FlatBufferBuilder, versionFirmwareMinor: UByte) = builder.addByte(19, versionFirmwareMinor.toByte(), 0)
        fun addVersionFirmwareGitHash(builder: FlatBufferBuilder, versionFirmwareGitHash: Int) = builder.addOffset(20, versionFirmwareGitHash, 0)
        fun addVersionFirmwareDate(builder: FlatBufferBuilder, versionFirmwareDate: Int) = builder.addOffset(21, versionFirmwareDate, 0)
        fun addModesAvailable(builder: FlatBufferBuilder, modesAvailable: Int) = builder.addOffset(22, modesAvailable, 0)
        fun createModesAvailableVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startModesAvailableVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addModeCurrent(builder: FlatBufferBuilder, modeCurrent: Int) = builder.addOffset(23, modeCurrent, 0)
        fun addModePinLabels(builder: FlatBufferBuilder, modePinLabels: Int) = builder.addOffset(24, modePinLabels, 0)
        fun createModePinLabelsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startModePinLabelsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addModeBitorderMsb(builder: FlatBufferBuilder, modeBitorderMsb: Boolean) = builder.addBoolean(25, modeBitorderMsb, false)
        fun addModeMaxPacketSize(builder: FlatBufferBuilder, modeMaxPacketSize: UInt) = builder.addInt(26, modeMaxPacketSize.toInt(), 0)
        fun addModeMaxWrite(builder: FlatBufferBuilder, modeMaxWrite: UInt) = builder.addInt(27, modeMaxWrite.toInt(), 0)
        fun addModeMaxRead(builder: FlatBufferBuilder, modeMaxRead: UInt) = builder.addInt(28, modeMaxRead.toInt(), 0)
        fun endStatusResponse(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
