// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

export class StatusResponse {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):StatusResponse {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsStatusResponse(bb:flatbuffers.ByteBuffer, obj?:StatusResponse):StatusResponse {
  return (obj || new StatusResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsStatusResponse(bb:flatbuffers.ByteBuffer, obj?:StatusResponse):StatusResponse {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new StatusResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

error():string|null
error(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
error(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

hardwareVersionMajor():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

hardwareVersionMinor():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

firmwareVersionMajor():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

firmwareVersionMinor():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

firmwareGitHash():string|null
firmwareGitHash(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
firmwareGitHash(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

firmwareDate():string|null
firmwareDate(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
firmwareDate(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

modesAvailable(index: number):string
modesAvailable(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
modesAvailable(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

modesAvailableLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

modeCurrent():string|null
modeCurrent(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
modeCurrent(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

modePinLabels(index: number):string
modePinLabels(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
modePinLabels(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

modePinLabelsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

modeBitorderMsb():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

psuEnabled():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

psuSetMv():number {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

psuSetMa():number {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

psuMeasuredMv():number {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

psuMeasuredMa():number {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

psuCurrentError():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

pullupEnabled():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

pullxConfig():number {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

adcMv(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.readUint32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
}

adcMvLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

adcMvArray():Uint32Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? new Uint32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

ioDirection():number {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

ioValue():number {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

diskSizeMb():number {
  const offset = this.bb!.__offset(this.bb_pos, 48);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

diskUsedMb():number {
  const offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

ledCount():number {
  const offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

static startStatusResponse(builder:flatbuffers.Builder) {
  builder.startObject(25);
}

static addError(builder:flatbuffers.Builder, errorOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, errorOffset, 0);
}

static addHardwareVersionMajor(builder:flatbuffers.Builder, hardwareVersionMajor:number) {
  builder.addFieldInt8(1, hardwareVersionMajor, 0);
}

static addHardwareVersionMinor(builder:flatbuffers.Builder, hardwareVersionMinor:number) {
  builder.addFieldInt8(2, hardwareVersionMinor, 0);
}

static addFirmwareVersionMajor(builder:flatbuffers.Builder, firmwareVersionMajor:number) {
  builder.addFieldInt8(3, firmwareVersionMajor, 0);
}

static addFirmwareVersionMinor(builder:flatbuffers.Builder, firmwareVersionMinor:number) {
  builder.addFieldInt8(4, firmwareVersionMinor, 0);
}

static addFirmwareGitHash(builder:flatbuffers.Builder, firmwareGitHashOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, firmwareGitHashOffset, 0);
}

static addFirmwareDate(builder:flatbuffers.Builder, firmwareDateOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, firmwareDateOffset, 0);
}

static addModesAvailable(builder:flatbuffers.Builder, modesAvailableOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, modesAvailableOffset, 0);
}

static createModesAvailableVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startModesAvailableVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addModeCurrent(builder:flatbuffers.Builder, modeCurrentOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, modeCurrentOffset, 0);
}

static addModePinLabels(builder:flatbuffers.Builder, modePinLabelsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, modePinLabelsOffset, 0);
}

static createModePinLabelsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startModePinLabelsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addModeBitorderMsb(builder:flatbuffers.Builder, modeBitorderMsb:boolean) {
  builder.addFieldInt8(10, +modeBitorderMsb, +false);
}

static addPsuEnabled(builder:flatbuffers.Builder, psuEnabled:boolean) {
  builder.addFieldInt8(11, +psuEnabled, +false);
}

static addPsuSetMv(builder:flatbuffers.Builder, psuSetMv:number) {
  builder.addFieldInt32(12, psuSetMv, 0);
}

static addPsuSetMa(builder:flatbuffers.Builder, psuSetMa:number) {
  builder.addFieldInt32(13, psuSetMa, 0);
}

static addPsuMeasuredMv(builder:flatbuffers.Builder, psuMeasuredMv:number) {
  builder.addFieldInt32(14, psuMeasuredMv, 0);
}

static addPsuMeasuredMa(builder:flatbuffers.Builder, psuMeasuredMa:number) {
  builder.addFieldInt32(15, psuMeasuredMa, 0);
}

static addPsuCurrentError(builder:flatbuffers.Builder, psuCurrentError:boolean) {
  builder.addFieldInt8(16, +psuCurrentError, +false);
}

static addPullupEnabled(builder:flatbuffers.Builder, pullupEnabled:boolean) {
  builder.addFieldInt8(17, +pullupEnabled, +false);
}

static addPullxConfig(builder:flatbuffers.Builder, pullxConfig:number) {
  builder.addFieldInt32(18, pullxConfig, 0);
}

static addAdcMv(builder:flatbuffers.Builder, adcMvOffset:flatbuffers.Offset) {
  builder.addFieldOffset(19, adcMvOffset, 0);
}

static createAdcMvVector(builder:flatbuffers.Builder, data:number[]|Uint32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createAdcMvVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createAdcMvVector(builder:flatbuffers.Builder, data:number[]|Uint32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]!);
  }
  return builder.endVector();
}

static startAdcMvVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addIoDirection(builder:flatbuffers.Builder, ioDirection:number) {
  builder.addFieldInt8(20, ioDirection, 0);
}

static addIoValue(builder:flatbuffers.Builder, ioValue:number) {
  builder.addFieldInt8(21, ioValue, 0);
}

static addDiskSizeMb(builder:flatbuffers.Builder, diskSizeMb:number) {
  builder.addFieldFloat32(22, diskSizeMb, 0.0);
}

static addDiskUsedMb(builder:flatbuffers.Builder, diskUsedMb:number) {
  builder.addFieldFloat32(23, diskUsedMb, 0.0);
}

static addLedCount(builder:flatbuffers.Builder, ledCount:number) {
  builder.addFieldInt8(24, ledCount, 0);
}

static endStatusResponse(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createStatusResponse(builder:flatbuffers.Builder, errorOffset:flatbuffers.Offset, hardwareVersionMajor:number, hardwareVersionMinor:number, firmwareVersionMajor:number, firmwareVersionMinor:number, firmwareGitHashOffset:flatbuffers.Offset, firmwareDateOffset:flatbuffers.Offset, modesAvailableOffset:flatbuffers.Offset, modeCurrentOffset:flatbuffers.Offset, modePinLabelsOffset:flatbuffers.Offset, modeBitorderMsb:boolean, psuEnabled:boolean, psuSetMv:number, psuSetMa:number, psuMeasuredMv:number, psuMeasuredMa:number, psuCurrentError:boolean, pullupEnabled:boolean, pullxConfig:number, adcMvOffset:flatbuffers.Offset, ioDirection:number, ioValue:number, diskSizeMb:number, diskUsedMb:number, ledCount:number):flatbuffers.Offset {
  StatusResponse.startStatusResponse(builder);
  StatusResponse.addError(builder, errorOffset);
  StatusResponse.addHardwareVersionMajor(builder, hardwareVersionMajor);
  StatusResponse.addHardwareVersionMinor(builder, hardwareVersionMinor);
  StatusResponse.addFirmwareVersionMajor(builder, firmwareVersionMajor);
  StatusResponse.addFirmwareVersionMinor(builder, firmwareVersionMinor);
  StatusResponse.addFirmwareGitHash(builder, firmwareGitHashOffset);
  StatusResponse.addFirmwareDate(builder, firmwareDateOffset);
  StatusResponse.addModesAvailable(builder, modesAvailableOffset);
  StatusResponse.addModeCurrent(builder, modeCurrentOffset);
  StatusResponse.addModePinLabels(builder, modePinLabelsOffset);
  StatusResponse.addModeBitorderMsb(builder, modeBitorderMsb);
  StatusResponse.addPsuEnabled(builder, psuEnabled);
  StatusResponse.addPsuSetMv(builder, psuSetMv);
  StatusResponse.addPsuSetMa(builder, psuSetMa);
  StatusResponse.addPsuMeasuredMv(builder, psuMeasuredMv);
  StatusResponse.addPsuMeasuredMa(builder, psuMeasuredMa);
  StatusResponse.addPsuCurrentError(builder, psuCurrentError);
  StatusResponse.addPullupEnabled(builder, pullupEnabled);
  StatusResponse.addPullxConfig(builder, pullxConfig);
  StatusResponse.addAdcMv(builder, adcMvOffset);
  StatusResponse.addIoDirection(builder, ioDirection);
  StatusResponse.addIoValue(builder, ioValue);
  StatusResponse.addDiskSizeMb(builder, diskSizeMb);
  StatusResponse.addDiskUsedMb(builder, diskUsedMb);
  StatusResponse.addLedCount(builder, ledCount);
  return StatusResponse.endStatusResponse(builder);
}
}
