// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

export class ModeConfiguration {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):ModeConfiguration {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsModeConfiguration(bb:flatbuffers.ByteBuffer, obj?:ModeConfiguration):ModeConfiguration {
  return (obj || new ModeConfiguration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsModeConfiguration(bb:flatbuffers.ByteBuffer, obj?:ModeConfiguration):ModeConfiguration {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ModeConfiguration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

speed():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 20000;
}

dataBits():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 8;
}

parity():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

stopBits():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 1;
}

flowControl():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

signalInversion():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

clockStretch():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

clockPolarity():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

clockPhase():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

chipSelectIdle():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : true;
}

submode():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

txModulation():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

rxSensor():number {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

static startModeConfiguration(builder:flatbuffers.Builder) {
  builder.startObject(13);
}

static addSpeed(builder:flatbuffers.Builder, speed:number) {
  builder.addFieldInt32(0, speed, 20000);
}

static addDataBits(builder:flatbuffers.Builder, dataBits:number) {
  builder.addFieldInt8(1, dataBits, 8);
}

static addParity(builder:flatbuffers.Builder, parity:boolean) {
  builder.addFieldInt8(2, +parity, +false);
}

static addStopBits(builder:flatbuffers.Builder, stopBits:number) {
  builder.addFieldInt8(3, stopBits, 1);
}

static addFlowControl(builder:flatbuffers.Builder, flowControl:boolean) {
  builder.addFieldInt8(4, +flowControl, +false);
}

static addSignalInversion(builder:flatbuffers.Builder, signalInversion:boolean) {
  builder.addFieldInt8(5, +signalInversion, +false);
}

static addClockStretch(builder:flatbuffers.Builder, clockStretch:boolean) {
  builder.addFieldInt8(6, +clockStretch, +false);
}

static addClockPolarity(builder:flatbuffers.Builder, clockPolarity:boolean) {
  builder.addFieldInt8(7, +clockPolarity, +false);
}

static addClockPhase(builder:flatbuffers.Builder, clockPhase:boolean) {
  builder.addFieldInt8(8, +clockPhase, +false);
}

static addChipSelectIdle(builder:flatbuffers.Builder, chipSelectIdle:boolean) {
  builder.addFieldInt8(9, +chipSelectIdle, +true);
}

static addSubmode(builder:flatbuffers.Builder, submode:number) {
  builder.addFieldInt8(10, submode, 0);
}

static addTxModulation(builder:flatbuffers.Builder, txModulation:number) {
  builder.addFieldInt32(11, txModulation, 0);
}

static addRxSensor(builder:flatbuffers.Builder, rxSensor:number) {
  builder.addFieldInt8(12, rxSensor, 0);
}

static endModeConfiguration(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createModeConfiguration(builder:flatbuffers.Builder, speed:number, dataBits:number, parity:boolean, stopBits:number, flowControl:boolean, signalInversion:boolean, clockStretch:boolean, clockPolarity:boolean, clockPhase:boolean, chipSelectIdle:boolean, submode:number, txModulation:number, rxSensor:number):flatbuffers.Offset {
  ModeConfiguration.startModeConfiguration(builder);
  ModeConfiguration.addSpeed(builder, speed);
  ModeConfiguration.addDataBits(builder, dataBits);
  ModeConfiguration.addParity(builder, parity);
  ModeConfiguration.addStopBits(builder, stopBits);
  ModeConfiguration.addFlowControl(builder, flowControl);
  ModeConfiguration.addSignalInversion(builder, signalInversion);
  ModeConfiguration.addClockStretch(builder, clockStretch);
  ModeConfiguration.addClockPolarity(builder, clockPolarity);
  ModeConfiguration.addClockPhase(builder, clockPhase);
  ModeConfiguration.addChipSelectIdle(builder, chipSelectIdle);
  ModeConfiguration.addSubmode(builder, submode);
  ModeConfiguration.addTxModulation(builder, txModulation);
  ModeConfiguration.addRxSensor(builder, rxSensor);
  return ModeConfiguration.endModeConfiguration(builder);
}
}
