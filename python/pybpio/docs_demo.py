from cobs import cobs
import serial
import time 
import os
import sys

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import flatbuffers

# Generated by `flatc`.
import tooling.bpio.ConfigurationRequest as ConfigurationRequest
import tooling.bpio.ConfigurationResponse as ConfigurationResponse
import tooling.bpio.DataRequest as DataRequest
import tooling.bpio.DataResponse as DataResponse
import tooling.bpio.ModeConfiguration as ModeConfiguration
import tooling.bpio.RequestPacket as RequestPacket
import tooling.bpio.RequestPacketContents as RequestPacketContents
import tooling.bpio.ResponsePacket as ResponsePacket
import tooling.bpio.ResponsePacketContents as ResponsePacketContents
import tooling.bpio.StatusRequest as StatusRequest
import tooling.bpio.StatusRequestTypes as StatusRequestTypes
import tooling.bpio.StatusResponse as StatusResponse

class flatbuffers_docs_demo:
    def __init__(self, port, baudrate=3000000, timeout=2, debug=False):
        self.port = port
        self.baudrate = baudrate
        self.timeout = timeout
        self.debug = debug
        self.serial_port = None
        
        # Open serial port
        try:
            self.serial_port = serial.Serial(self.port, self.baudrate, timeout=self.timeout)
            if self.debug:
                print(f"Opened serial port {self.port} at {self.baudrate} baud")
        except serial.SerialException as e:
            print(f"Failed to open serial port {self.port}: {e}")
            print("Make sure the serial port exists and is not in use by another application")
            raise
        except Exception as e:
            print(f"Error opening serial port: {e}")
            raise
    
    def __enter__(self):
        """Context manager entry"""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit"""
        self.close()
    
    def close(self):
        """Close the serial port"""
        if self.serial_port and self.serial_port.is_open:
            self.serial_port.close()
            if self.debug:
                print(f"Closed serial port {self.port}")
    
    def __del__(self):
        """Destructor - ensure port is closed"""
        self.close()
        
    def send_and_receive(self, data):
        """Send COBS-encoded data to serial port and receive COBS-encoded response"""
        if not self.serial_port or not self.serial_port.is_open:
            print("Serial port is not open")
            return None
            
        try:
            # Clear any pending data
            self.serial_port.reset_input_buffer()
            self.serial_port.reset_output_buffer()
            
            # Send COBS-encoded data followed by delimiter (0x00)
            packet = cobs.encode(data) + b'\x00'
            self.serial_port.write(packet)
            
            if self.debug:
                print(f"Sent {len(data)} bytes (original data)")
                print(f"Total bytes sent: {len(packet) + 1} (COBS + delimiter)")

            # Read response until we get the delimiter (0x00) - most efficient
            resp_encoded = bytearray()
            timeout_start = time.time()

            while True:
                # Read all available data at once
                available = self.serial_port.in_waiting
                if available > 0:
                    chunk = self.serial_port.read(available)
                    resp_encoded.extend(chunk)
                    
                    # Check if we have the complete message (contains delimiter)
                    delimiter_pos = resp_encoded.find(b'\x00')
                    if delimiter_pos != -1:
                        # Found delimiter, truncate at delimiter position
                        resp_encoded = resp_encoded[:delimiter_pos]
                        break
                else:
                    # No data available, check timeout
                    if time.time() - timeout_start > self.timeout:
                        print("Timeout waiting for response")
                        return None
                    time.sleep(0.001)  # Small delay to prevent busy waiting

            # Convert back to bytes
            resp_encoded = bytes(resp_encoded)
            
            if len(resp_encoded) == 0:
                print("No response data received")
                return None
                
            if self.debug:
                print(f"Received {len(resp_encoded)} bytes (COBS encoded)")
            
            # COBS decode the response
            try:
                resp_data = cobs.decode(resp_encoded)
                if self.debug:
                    print(f"Decoded {len(resp_data)} bytes")
                return resp_data
            except cobs.DecodeError as e:
                print(f"COBS decode error: {e}")
                return None

        except serial.SerialException as e:
            print(f"Serial communication error: {e}")
        except Exception as e:
            print(f"Error: {e}")
        return None

    def status_request(self):
        """Send a StatusRequest packet and return the response"""
        """Wrap contents in a RequestPacket"""

        # Create a flatbuffers builder
        builder = flatbuffers.Builder(1024)

        # Create the query vector BEFORE starting the StatusRequest table
        StatusRequest.StartQueryVector(builder, 1)
        builder.PrependUint8(StatusRequestTypes.StatusRequestTypes.All)
        query_vector = builder.EndVector()

        # Create a StatusRequest
        StatusRequest.Start(builder)
        StatusRequest.AddQuery(builder, query_vector) # Add the query vector
        status_request = StatusRequest.End(builder)

        # Create a RequestPacket
        RequestPacket.Start(builder)
        RequestPacket.AddVersionMajor(builder, 2) 
        RequestPacket.AddMinimumVersionMinor(builder, 0) # Update to match the minimum version tooling required
        RequestPacket.AddContentsType(builder, RequestPacketContents.RequestPacketContents.StatusRequest) # Add the StatusRequest type
        RequestPacket.AddContents(builder, status_request) # Add the StatusRequest
        request_packet = RequestPacket.End(builder)

        # Finish the builder and get the data
        builder.Finish(request_packet)
        data = builder.Output()
    
        # COBS encode request and send to the serial port
        resp_data = self.send_and_receive(data)

        # Check for the response
        if not resp_data:
            return False

        # Decode ResponsePacket
        resp_packet = ResponsePacket.ResponsePacket.GetRootAsResponsePacket(resp_data, 0)

        # Check for ErrorResponse
        if resp_packet.Error():
            print(f"Error: {resp_packet.Error().decode('utf-8')}")
            return False
  
        # Confirm the response type matches expected
        response_contents_type = resp_packet.ContentsType()
        if response_contents_type != ResponsePacketContents.ResponsePacketContents.StatusResponse:
            print(f"Unexpected response type: {response_contents_type}")
            return False

        # Decode StatusResponse
        status_resp = StatusResponse.StatusResponse()
        status_resp.Init(resp_packet.Contents().Bytes, resp_packet.Contents().Pos)

        # Print hardware and firmware versions
        print(f"  Hardware version: {status_resp.VersionHardwareMajor()} REV{status_resp.VersionHardwareMinor()}")
        print(f"  Firmware version: {status_resp.VersionFirmwareMajor()}.{status_resp.VersionFirmwareMinor()}")
        print(f"  Firmware git hash: {status_resp.VersionFirmwareGitHash().decode('utf-8')}")
        print(f"  Firmware date: {status_resp.VersionFirmwareDate().decode('utf-8')}")

        # Print available modes
        modes_available = [status_resp.ModesAvailable(i).decode('utf-8') for i in range(status_resp.ModesAvailableLength())]
        print(f"  Available modes: {', '.join(modes_available)}")

        # copy the status response into a dictionary
        status_dict = {
            'error': status_resp.Error().decode('utf-8') if status_resp.Error() else None,
            'version_flatbuffers_major': status_resp.VersionFlatbuffersMajor(),
            'version_flatbuffers_minor': status_resp.VersionFlatbuffersMinor(),
            'version_hardware_major': status_resp.VersionHardwareMajor(),
            'version_hardware_minor': status_resp.VersionHardwareMinor(),
            'version_firmware_major': status_resp.VersionFirmwareMajor(),
            'version_firmware_minor': status_resp.VersionFirmwareMinor(),
            'version_firmware_git_hash': status_resp.VersionFirmwareGitHash().decode('utf-8'),
            'version_firmware_date': status_resp.VersionFirmwareDate().decode('utf-8'),
            'modes_available': [status_resp.ModesAvailable(i).decode('utf-8') for i in range(status_resp.ModesAvailableLength())],
            'mode_current': status_resp.ModeCurrent().decode('utf-8') if status_resp.ModeCurrent() else None,
            'mode_pin_labels': [status_resp.ModePinLabels(i).decode('utf-8') for i in range(status_resp.ModePinLabelsLength())],
            'mode_bitorder_msb': status_resp.ModeBitorderMsb(),
            'mode_max_packet_size': status_resp.ModeMaxPacketSize(),
            'mode_max_write': status_resp.ModeMaxWrite(),
            'mode_max_read': status_resp.ModeMaxRead(),
            'psu_enabled': status_resp.PsuEnabled(),
            'psu_set_mv': status_resp.PsuSetMv(),
            'psu_set_ma': status_resp.PsuSetMa(),
            'psu_measured_mv': status_resp.PsuMeasuredMv(),
            'psu_measured_ma': status_resp.PsuMeasuredMa(),
            'psu_current_error': status_resp.PsuCurrentError(),
            'pullup_enabled': status_resp.PullupEnabled(),
            'adc_mv': [status_resp.AdcMv(i) for i in range(status_resp.AdcMvLength())],
            'io_direction': status_resp.IoDirection(),
            'io_value': status_resp.IoValue(),
            'disk_size_mb': status_resp.DiskSizeMb(),
            'disk_used_mb': status_resp.DiskUsedMb(),
            'led_count': status_resp.LedCount()
        }

        return status_dict        

    
    def configuration_request(self):
        """Create a BPIO ConfigurationRequest packet"""
        builder = flatbuffers.Builder(1024)

        # Create a mode string
        mode_string = builder.CreateString("SPI")

        # Create a ModeConfiguration
        ModeConfiguration.Start(builder)
        ModeConfiguration.AddSpeed(builder, 1000000)
        ModeConfiguration.AddChipSelectIdle(builder, True)
        ModeConfiguration.AddClockPhase(builder, False)
        ModeConfiguration.AddClockPolarity(builder, False)
        ModeConfiguration.AddDataBits(builder, 8)
        mode_config = ModeConfiguration.End(builder)

        # Set the LED colors
        led_colors = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF] * 3
        ConfigurationRequest.StartLedColorVector(builder, len(led_colors))
        for color in reversed(led_colors):
            builder.PrependUint32(color)
        led_color_vector = builder.EndVector()    
        
        # Create the ConfigurationRequest
        ConfigurationRequest.Start(builder)
        ConfigurationRequest.AddMode(builder, mode_string)
        ConfigurationRequest.AddModeConfiguration(builder, mode_config)
        ConfigurationRequest.AddPsuEnable(builder, True)
        ConfigurationRequest.AddPsuSetMv(builder, 3300)
        ConfigurationRequest.AddPsuSetMa(builder, 300)
        ConfigurationRequest.AddPullupEnable(builder, True)
        ConfigurationRequest.AddLedColor(builder, led_color_vector) 
        config_request = ConfigurationRequest.End(builder)

        # Create a RequestPacket
        RequestPacket.Start(builder)
        RequestPacket.AddVersionMajor(builder, 2) 
        RequestPacket.AddMinimumVersionMinor(builder, 0) # Update to match the minimum version tooling required
        RequestPacket.AddContentsType(builder, RequestPacketContents.RequestPacketContents.ConfigurationRequest) # Add the ConfigRequest type
        RequestPacket.AddContents(builder, config_request) # Add the ConfigRequest
        request_packet = RequestPacket.End(builder)

        # Finish the builder and get the data
        builder.Finish(request_packet)
        data = builder.Output()
    
        # COBS encode request and send to the serial port
        resp_data = self.send_and_receive(data)

        # Check for the response
        if not resp_data:
            return False

        # Decode ResponsePacket
        resp_packet = ResponsePacket.ResponsePacket.GetRootAsResponsePacket(resp_data, 0)

        # Check for ErrorResponse
        if resp_packet.Error():
            print(f"Error: {resp_packet.Error().decode('utf-8')}")
            return False     
  
        # Confirm the response type matches expected
        response_contents_type = resp_packet.ContentsType()
        if response_contents_type != ResponsePacketContents.ResponsePacketContents.ConfigurationResponse:
            print(f"Unexpected response type: {response_contents_type}")
            return False        

        # Decode ConfigurationResponse
        config_resp = ConfigurationResponse.ConfigurationResponse()
        config_resp.Init(resp_packet.Contents().Bytes, resp_packet.Contents().Pos)

        # Print the error message if any
        if config_resp.Error():
            print(f"Configuration error: {config_resp.Error().decode('utf-8')}")
            return False
        
        return True


    def data_request(self):
        """Create a BPIO DataRequest packet"""
        builder = flatbuffers.Builder(1024)

        # Define the data to write
        data_write = [0x9F]
        data_write_vector = builder.CreateByteVector(bytes(data_write))

        # Create a DataRequest
        DataRequest.Start(builder)
        DataRequest.AddStartMain(builder, True)
        DataRequest.AddDataWrite(builder, data_write_vector)
        DataRequest.AddBytesRead(builder, 3)
        DataRequest.AddStopMain(builder, True)
        data_request = DataRequest.End(builder)

        # Create a RequestPacket
        RequestPacket.Start(builder)
        RequestPacket.AddVersionMajor(builder, 2)
        RequestPacket.AddMinimumVersionMinor(builder, 0) # Update to match the minimum version tooling required
        RequestPacket.AddContentsType(builder, RequestPacketContents.RequestPacketContents.DataRequest) # Add the DataRequest type
        RequestPacket.AddContents(builder, data_request) # Add the DataRequest
        request_packet = RequestPacket.End(builder)

        # Finish the builder and get the data
        builder.Finish(request_packet)
        data = builder.Output()
    
        # COBS encode request and send to the serial port
        resp_data = self.send_and_receive(data)

        # Check for the response
        if not resp_data:
            return False        

        # Decode ResponsePacket
        resp_packet = ResponsePacket.ResponsePacket.GetRootAsResponsePacket(resp_data, 0)

        # Check for ErrorResponse
        if resp_packet.Error():
            print(f"Error: {resp_packet.Error().decode('utf-8')}")
            return False        
  
        # Confirm the response type matches expected
        response_contents_type = resp_packet.ContentsType()
        if response_contents_type != ResponsePacketContents.ResponsePacketContents.DataResponse:
            print(f"Unexpected response type: {response_contents_type}")
            return False     

        # Decode DataResponse
        data_resp = DataResponse.DataResponse()
        data_resp.Init(resp_packet.Contents().Bytes, resp_packet.Contents().Pos)
        
        # Print the error message if any
        if data_resp.Error():
            print(f"Data request error: {data_resp.Error().decode('utf-8')}")
            return False

        # Return data read, if any
        if data_resp.DataReadLength() > 0:
            data_bytes = data_resp.DataReadAsNumpy()
            print(f"Data read: {' '.join(f'{b:02x}' for b in data_bytes)}")
            return data_bytes.tobytes()
        else:
            return None
            
demo = flatbuffers_docs_demo(port='COM35')
if demo.status_request():
    if demo.configuration_request():
        data = demo.data_request()