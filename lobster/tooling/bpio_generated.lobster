// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

namespace bpio

enum StatusRequestTypes:
    StatusRequestTypes_All = 0
    StatusRequestTypes_Version = 1
    StatusRequestTypes_Mode = 2
    StatusRequestTypes_Pullup = 3
    StatusRequestTypes_PSU = 4
    StatusRequestTypes_ADC = 5
    StatusRequestTypes_IO = 6
    StatusRequestTypes_Disk = 7
    StatusRequestTypes_LED = 8

enum Color:
    Color_Red = 0
    Color_Green = 1
    Color_Blue = 2

enum Equipment:
    Equipment_NONE = 0
    Equipment_Weapon = 1

enum RequestPacketContents:
    RequestPacketContents_NONE = 0
    RequestPacketContents_Monster = 1
    RequestPacketContents_StatusRequest = 2
    RequestPacketContents_ConfigurationRequest = 3
    RequestPacketContents_DataRequest = 4

enum ResponsePacketContents:
    ResponsePacketContents_NONE = 0
    ResponsePacketContents_ErrorResponse = 1
    ResponsePacketContents_Monster = 2
    ResponsePacketContents_ConfigurationResponse = 3
    ResponsePacketContents_StatusResponse = 4
    ResponsePacketContents_DataResponse = 5

class StatusRequest

class Vec3

class Monster

class Weapon

class StatusResponse

class ModeConfiguration

class ConfigurationRequest

class ConfigurationResponse

class DataRequest

class DataResponse

class ErrorResponse

class RequestPacket

class ResponsePacket

class StatusRequest : flatbuffers.handle
    def query(i:int) -> StatusRequestTypes:
        return read_int8_le(buf_, buf_.flatbuffers.field_vector(pos_, 4) + i * 1)
    def query_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)

def GetRootAsStatusRequest(buf:string): return StatusRequest { buf, flatbuffers.indirect(buf, 0) }

struct StatusRequestBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_query(query:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, query)
        return this
    def end():
        return b_.EndObject()

def StatusRequestStartQueryVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def StatusRequestCreateQueryVector(b_:flatbuffers.builder, v_:[StatusRequestTypes]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependInt8(e_)
    return b_.EndVector(v_.length)

class Vec3 : flatbuffers.handle
    def x() -> float:
        return buf_.read_float32_le(pos_ + 0)
    def y() -> float:
        return buf_.read_float32_le(pos_ + 4)
    def z() -> float:
        return buf_.read_float32_le(pos_ + 8)

def CreateVec3(b_:flatbuffers.builder, x:float, y:float, z:float):
    b_.Prep(4, 12)
    b_.PrependFloat32(z)
    b_.PrependFloat32(y)
    b_.PrependFloat32(x)
    return b_.Offset()

class Monster : flatbuffers.handle
    def pos() -> bpio.Vec3?:
        let o = flatbuffers.field_struct(buf_, pos_, 4)
        return if o: bpio.Vec3 { buf_, o } else: nil
    def mana() -> int:
        return flatbuffers.field_int16(buf_, pos_, 6, 150)
    def hp() -> int:
        return flatbuffers.field_int16(buf_, pos_, 8, 100)
    def name() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    def inventory(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 14) + i * 1)
    def inventory_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 14)
    def color() -> Color:
        return Color(flatbuffers.field_int8(buf_, pos_, 16, 2))
    def weapons(i:int) -> bpio.Weapon:
        return bpio.Weapon { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 18) + i * 4) }
    def weapons_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 18)
    def equipped_type() -> Equipment:
        return Equipment(flatbuffers.field_uint8(buf_, pos_, 20, 0))
    def equipped_as_Weapon():
        return bpio.Weapon { buf_, flatbuffers.field_table(buf_, pos_, 22) }
    def path(i:int) -> bpio.Vec3:
        return bpio.Vec3 { buf_, flatbuffers.field_vector(buf_, pos_, 24) + i * 12 }
    def path_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 24)

def GetRootAsMonster(buf:string): return Monster { buf, flatbuffers.indirect(buf, 0) }

struct MonsterBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(11)
        return this
    def add_pos(pos:flatbuffers.offset):
        b_.PrependStructSlot(0, pos)
        return this
    def add_mana(mana:int):
        b_.PrependInt16Slot(1, mana, 150)
        return this
    def add_hp(hp:int):
        b_.PrependInt16Slot(2, hp, 100)
        return this
    def add_name(name:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, name)
        return this
    def add_inventory(inventory:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, inventory)
        return this
    def add_color(color:Color):
        b_.PrependInt8Slot(6, color, 2)
        return this
    def add_weapons(weapons:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, weapons)
        return this
    def add_equipped_type(equipped_type:Equipment):
        b_.PrependUint8Slot(8, equipped_type, 0)
        return this
    def add_equipped(equipped:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, equipped)
        return this
    def add_path(path:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, path)
        return this
    def end():
        return b_.EndObject()

def MonsterStartInventoryVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def MonsterCreateInventoryVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

def MonsterStartWeaponsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MonsterCreateWeaponsVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def MonsterStartPathVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(12, n_, 4)

class Weapon : flatbuffers.handle
    def name() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    def damage() -> int:
        return flatbuffers.field_int16(buf_, pos_, 6, 0)

def GetRootAsWeapon(buf:string): return Weapon { buf, flatbuffers.indirect(buf, 0) }

struct WeaponBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_name(name:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, name)
        return this
    def add_damage(damage:int):
        b_.PrependInt16Slot(1, damage, 0)
        return this
    def end():
        return b_.EndObject()

class StatusResponse : flatbuffers.handle
    def error() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    def psu_enabled() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 6, 0))
    def psu_set_mv() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 8, 0)
    def psu_set_ma() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 10, 0)
    def psu_measured_mv() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 12, 0)
    def psu_measured_ma() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 14, 0)
    def psu_current_error() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 16, 0))
    def pullup_enabled() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 18, 0))
    def adc_mv(i:int) -> int:
        return read_uint32_le(buf_, buf_.flatbuffers.field_vector(pos_, 20) + i * 4)
    def adc_mv_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 20)
    def io_direction() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 22, 0)
    def io_value() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 24, 0)
    def disk_size_mb() -> float:
        return flatbuffers.field_float32(buf_, pos_, 26, 0.0)
    def disk_used_mb() -> float:
        return flatbuffers.field_float32(buf_, pos_, 28, 0.0)
    def led_count() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 30, 0)
    def version_flatbuffers_major() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 32, 0)
    def version_flatbuffers_minor() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 34, 0)
    def version_hardware_major() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 36, 0)
    def version_hardware_minor() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 38, 0)
    def version_firmware_major() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 40, 0)
    def version_firmware_minor() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 42, 0)
    def version_firmware_git_hash() -> string:
        return flatbuffers.field_string(buf_, pos_, 44)
    def version_firmware_date() -> string:
        return flatbuffers.field_string(buf_, pos_, 46)
    def modes_available(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 48) + i * 4)
    def modes_available_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 48)
    def mode_current() -> string:
        return flatbuffers.field_string(buf_, pos_, 50)
    def mode_pin_labels(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 52) + i * 4)
    def mode_pin_labels_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 52)
    def mode_bitorder_msb() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 54, 0))
    def mode_max_packet_size() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 56, 0)
    def mode_max_write() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 58, 0)
    def mode_max_read() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 60, 0)

def GetRootAsStatusResponse(buf:string): return StatusResponse { buf, flatbuffers.indirect(buf, 0) }

struct StatusResponseBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(29)
        return this
    def add_error(error:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, error)
        return this
    def add_psu_enabled(psu_enabled:bool):
        b_.PrependBoolSlot(1, psu_enabled, 0)
        return this
    def add_psu_set_mv(psu_set_mv:int):
        b_.PrependUint32Slot(2, psu_set_mv, 0)
        return this
    def add_psu_set_ma(psu_set_ma:int):
        b_.PrependUint32Slot(3, psu_set_ma, 0)
        return this
    def add_psu_measured_mv(psu_measured_mv:int):
        b_.PrependUint32Slot(4, psu_measured_mv, 0)
        return this
    def add_psu_measured_ma(psu_measured_ma:int):
        b_.PrependUint32Slot(5, psu_measured_ma, 0)
        return this
    def add_psu_current_error(psu_current_error:bool):
        b_.PrependBoolSlot(6, psu_current_error, 0)
        return this
    def add_pullup_enabled(pullup_enabled:bool):
        b_.PrependBoolSlot(7, pullup_enabled, 0)
        return this
    def add_adc_mv(adc_mv:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, adc_mv)
        return this
    def add_io_direction(io_direction:int):
        b_.PrependUint8Slot(9, io_direction, 0)
        return this
    def add_io_value(io_value:int):
        b_.PrependUint8Slot(10, io_value, 0)
        return this
    def add_disk_size_mb(disk_size_mb:float):
        b_.PrependFloat32Slot(11, disk_size_mb, 0.0)
        return this
    def add_disk_used_mb(disk_used_mb:float):
        b_.PrependFloat32Slot(12, disk_used_mb, 0.0)
        return this
    def add_led_count(led_count:int):
        b_.PrependUint8Slot(13, led_count, 0)
        return this
    def add_version_flatbuffers_major(version_flatbuffers_major:int):
        b_.PrependUint8Slot(14, version_flatbuffers_major, 0)
        return this
    def add_version_flatbuffers_minor(version_flatbuffers_minor:int):
        b_.PrependUint16Slot(15, version_flatbuffers_minor, 0)
        return this
    def add_version_hardware_major(version_hardware_major:int):
        b_.PrependUint8Slot(16, version_hardware_major, 0)
        return this
    def add_version_hardware_minor(version_hardware_minor:int):
        b_.PrependUint8Slot(17, version_hardware_minor, 0)
        return this
    def add_version_firmware_major(version_firmware_major:int):
        b_.PrependUint8Slot(18, version_firmware_major, 0)
        return this
    def add_version_firmware_minor(version_firmware_minor:int):
        b_.PrependUint8Slot(19, version_firmware_minor, 0)
        return this
    def add_version_firmware_git_hash(version_firmware_git_hash:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(20, version_firmware_git_hash)
        return this
    def add_version_firmware_date(version_firmware_date:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(21, version_firmware_date)
        return this
    def add_modes_available(modes_available:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(22, modes_available)
        return this
    def add_mode_current(mode_current:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(23, mode_current)
        return this
    def add_mode_pin_labels(mode_pin_labels:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(24, mode_pin_labels)
        return this
    def add_mode_bitorder_msb(mode_bitorder_msb:bool):
        b_.PrependBoolSlot(25, mode_bitorder_msb, 0)
        return this
    def add_mode_max_packet_size(mode_max_packet_size:int):
        b_.PrependUint32Slot(26, mode_max_packet_size, 0)
        return this
    def add_mode_max_write(mode_max_write:int):
        b_.PrependUint32Slot(27, mode_max_write, 0)
        return this
    def add_mode_max_read(mode_max_read:int):
        b_.PrependUint32Slot(28, mode_max_read, 0)
        return this
    def end():
        return b_.EndObject()

def StatusResponseStartAdcMvVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def StatusResponseCreateAdcMvVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUint32(e_)
    return b_.EndVector(v_.length)

def StatusResponseStartModesAvailableVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def StatusResponseCreateModesAvailableVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def StatusResponseStartModePinLabelsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def StatusResponseCreateModePinLabelsVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

class ModeConfiguration : flatbuffers.handle
    def speed() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 4, 20000)
    def data_bits() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 6, 8)
    def parity() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 8, 0))
    def stop_bits() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 10, 1)
    def flow_control() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 12, 0))
    def signal_inversion() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 14, 0))
    def submode() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 16, 0)
    def tx_modulation() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 18, 0)
    def rx_sensor() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 20, 0)

def GetRootAsModeConfiguration(buf:string): return ModeConfiguration { buf, flatbuffers.indirect(buf, 0) }

struct ModeConfigurationBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(9)
        return this
    def add_speed(speed:int):
        b_.PrependUint32Slot(0, speed, 20000)
        return this
    def add_data_bits(data_bits:int):
        b_.PrependUint8Slot(1, data_bits, 8)
        return this
    def add_parity(parity:bool):
        b_.PrependBoolSlot(2, parity, 0)
        return this
    def add_stop_bits(stop_bits:int):
        b_.PrependUint8Slot(3, stop_bits, 1)
        return this
    def add_flow_control(flow_control:bool):
        b_.PrependBoolSlot(4, flow_control, 0)
        return this
    def add_signal_inversion(signal_inversion:bool):
        b_.PrependBoolSlot(5, signal_inversion, 0)
        return this
    def add_submode(submode:int):
        b_.PrependUint8Slot(6, submode, 0)
        return this
    def add_tx_modulation(tx_modulation:int):
        b_.PrependUint32Slot(7, tx_modulation, 0)
        return this
    def add_rx_sensor(rx_sensor:int):
        b_.PrependUint8Slot(8, rx_sensor, 0)
        return this
    def end():
        return b_.EndObject()

class ConfigurationRequest : flatbuffers.handle
    def mode() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    def mode_configuration() -> bpio.ModeConfiguration?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: bpio.ModeConfiguration { buf_, o } else: nil
    def mode_bitorder_msb() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 8, 0))
    def mode_bitorder_lsb() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 10, 0))
    def psu_disable() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 12, 0))
    def psu_enable() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 14, 0))
    def psu_set_mv() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 16, 0)
    def psu_set_ma() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 18, 300)
    def pullup_disable() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 20, 0))
    def pullup_enable() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 22, 0))
    def io_direction_mask() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 24, 0)
    def io_direction() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 26, 0)
    def io_value_mask() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 28, 0)
    def io_value() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 30, 0)

def GetRootAsConfigurationRequest(buf:string): return ConfigurationRequest { buf, flatbuffers.indirect(buf, 0) }

struct ConfigurationRequestBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(14)
        return this
    def add_mode(mode:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, mode)
        return this
    def add_mode_configuration(mode_configuration:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, mode_configuration)
        return this
    def add_mode_bitorder_msb(mode_bitorder_msb:bool):
        b_.PrependBoolSlot(2, mode_bitorder_msb, 0)
        return this
    def add_mode_bitorder_lsb(mode_bitorder_lsb:bool):
        b_.PrependBoolSlot(3, mode_bitorder_lsb, 0)
        return this
    def add_psu_disable(psu_disable:bool):
        b_.PrependBoolSlot(4, psu_disable, 0)
        return this
    def add_psu_enable(psu_enable:bool):
        b_.PrependBoolSlot(5, psu_enable, 0)
        return this
    def add_psu_set_mv(psu_set_mv:int):
        b_.PrependUint32Slot(6, psu_set_mv, 0)
        return this
    def add_psu_set_ma(psu_set_ma:int):
        b_.PrependUint16Slot(7, psu_set_ma, 300)
        return this
    def add_pullup_disable(pullup_disable:bool):
        b_.PrependBoolSlot(8, pullup_disable, 0)
        return this
    def add_pullup_enable(pullup_enable:bool):
        b_.PrependBoolSlot(9, pullup_enable, 0)
        return this
    def add_io_direction_mask(io_direction_mask:int):
        b_.PrependUint8Slot(10, io_direction_mask, 0)
        return this
    def add_io_direction(io_direction:int):
        b_.PrependUint8Slot(11, io_direction, 0)
        return this
    def add_io_value_mask(io_value_mask:int):
        b_.PrependUint8Slot(12, io_value_mask, 0)
        return this
    def add_io_value(io_value:int):
        b_.PrependUint8Slot(13, io_value, 0)
        return this
    def end():
        return b_.EndObject()

class ConfigurationResponse : flatbuffers.handle
    def error() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)

def GetRootAsConfigurationResponse(buf:string): return ConfigurationResponse { buf, flatbuffers.indirect(buf, 0) }

struct ConfigurationResponseBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_error(error:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, error)
        return this
    def end():
        return b_.EndObject()

class DataRequest : flatbuffers.handle
    def start_main() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 4, 0))
    def start_alt() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 6, 0))
    def data_write(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 8) + i * 1)
    def data_write_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 8)

def GetRootAsDataRequest(buf:string): return DataRequest { buf, flatbuffers.indirect(buf, 0) }

struct DataRequestBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_start_main(start_main:bool):
        b_.PrependBoolSlot(0, start_main, 0)
        return this
    def add_start_alt(start_alt:bool):
        b_.PrependBoolSlot(1, start_alt, 0)
        return this
    def add_data_write(data_write:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, data_write)
        return this
    def end():
        return b_.EndObject()

def DataRequestStartDataWriteVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def DataRequestCreateDataWriteVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

class DataResponse : flatbuffers.handle
    def error() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    def data_read(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 6) + i * 1)
    def data_read_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 6)

def GetRootAsDataResponse(buf:string): return DataResponse { buf, flatbuffers.indirect(buf, 0) }

struct DataResponseBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_error(error:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, error)
        return this
    def add_data_read(data_read:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, data_read)
        return this
    def end():
        return b_.EndObject()

def DataResponseStartDataReadVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def DataResponseCreateDataReadVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

class ErrorResponse : flatbuffers.handle
    def error() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)

def GetRootAsErrorResponse(buf:string): return ErrorResponse { buf, flatbuffers.indirect(buf, 0) }

struct ErrorResponseBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_error(error:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, error)
        return this
    def end():
        return b_.EndObject()

class RequestPacket : flatbuffers.handle
    def version_major() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 4, 0)
    def minimum_version_minor() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 6, 0)
    def contents_type() -> RequestPacketContents:
        return RequestPacketContents(flatbuffers.field_uint8(buf_, pos_, 8, 0))
    def contents_as_Monster():
        return bpio.Monster { buf_, flatbuffers.field_table(buf_, pos_, 10) }
    def contents_as_StatusRequest():
        return bpio.StatusRequest { buf_, flatbuffers.field_table(buf_, pos_, 10) }
    def contents_as_ConfigurationRequest():
        return bpio.ConfigurationRequest { buf_, flatbuffers.field_table(buf_, pos_, 10) }
    def contents_as_DataRequest():
        return bpio.DataRequest { buf_, flatbuffers.field_table(buf_, pos_, 10) }

def GetRootAsRequestPacket(buf:string): return RequestPacket { buf, flatbuffers.indirect(buf, 0) }

struct RequestPacketBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_version_major(version_major:int):
        b_.PrependUint8Slot(0, version_major, 0)
        return this
    def add_minimum_version_minor(minimum_version_minor:int):
        b_.PrependUint16Slot(1, minimum_version_minor, 0)
        return this
    def add_contents_type(contents_type:RequestPacketContents):
        b_.PrependUint8Slot(2, contents_type, 0)
        return this
    def add_contents(contents:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, contents)
        return this
    def end():
        return b_.EndObject()

class ResponsePacket : flatbuffers.handle
    def error() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    def contents_type() -> ResponsePacketContents:
        return ResponsePacketContents(flatbuffers.field_uint8(buf_, pos_, 6, 0))
    def contents_as_ErrorResponse():
        return bpio.ErrorResponse { buf_, flatbuffers.field_table(buf_, pos_, 8) }
    def contents_as_Monster():
        return bpio.Monster { buf_, flatbuffers.field_table(buf_, pos_, 8) }
    def contents_as_ConfigurationResponse():
        return bpio.ConfigurationResponse { buf_, flatbuffers.field_table(buf_, pos_, 8) }
    def contents_as_StatusResponse():
        return bpio.StatusResponse { buf_, flatbuffers.field_table(buf_, pos_, 8) }
    def contents_as_DataResponse():
        return bpio.DataResponse { buf_, flatbuffers.field_table(buf_, pos_, 8) }

def GetRootAsResponsePacket(buf:string): return ResponsePacket { buf, flatbuffers.indirect(buf, 0) }

struct ResponsePacketBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_error(error:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, error)
        return this
    def add_contents_type(contents_type:ResponsePacketContents):
        b_.PrependUint8Slot(1, contents_type, 0)
        return this
    def add_contents(contents:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, contents)
        return this
    def end():
        return b_.EndObject()

