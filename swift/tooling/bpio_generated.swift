// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

#if canImport(Common)
import Common
#endif

import FlatBuffers

public enum bpio_StatusRequestTypes: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case all = 0
  case version = 1
  case mode = 2
  case pullup = 3
  case psu = 4
  case adc = 5
  case io = 6
  case disk = 7
  case led = 8

  public static var max: bpio_StatusRequestTypes { return .led }
  public static var min: bpio_StatusRequestTypes { return .all }
}


public enum bpio_Color: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case red = 0
  case green = 1
  case blue = 2

  public static var max: bpio_Color { return .blue }
  public static var min: bpio_Color { return .red }
}


public enum bpio_Equipment: UInt8, UnionEnum {
  public typealias T = UInt8

  public init?(value: T) {
    self.init(rawValue: value)
  }

  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case weapon = 1

  public static var max: bpio_Equipment { return .weapon }
  public static var min: bpio_Equipment { return .none_ }
}


public enum bpio_RequestPacketContents: UInt8, UnionEnum {
  public typealias T = UInt8

  public init?(value: T) {
    self.init(rawValue: value)
  }

  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case monster = 1
  case statusrequest = 2
  case configurationrequest = 3
  case datarequest = 4

  public static var max: bpio_RequestPacketContents { return .datarequest }
  public static var min: bpio_RequestPacketContents { return .none_ }
}


public enum bpio_ResponsePacketContents: UInt8, UnionEnum {
  public typealias T = UInt8

  public init?(value: T) {
    self.init(rawValue: value)
  }

  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case errorresponse = 1
  case monster = 2
  case configurationresponse = 3
  case statusresponse = 4
  case dataresponse = 5

  public static var max: bpio_ResponsePacketContents { return .dataresponse }
  public static var min: bpio_ResponsePacketContents { return .none_ }
}


public struct bpio_Vec3: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }

  private var _x: Float32
  private var _y: Float32
  private var _z: Float32

  public init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _x = _accessor.readBuffer(of: Float32.self, at: 0)
    _y = _accessor.readBuffer(of: Float32.self, at: 4)
    _z = _accessor.readBuffer(of: Float32.self, at: 8)
  }

  public init(x: Float32, y: Float32, z: Float32) {
    _x = x
    _y = y
    _z = z
  }

  public init() {
    _x = 0.0
    _y = 0.0
    _z = 0.0
  }

  public var x: Float32 { _x }
  public var y: Float32 { _y }
  public var z: Float32 { _z }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: bpio_Vec3.self)
  }
}

public struct bpio_Vec3_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var x: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  public var y: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
  public var z: Float32 { return _accessor.readBuffer(of: Float32.self, at: 8) }
}

public struct bpio_StatusRequest: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case query = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasQuery: Bool { let o = _accessor.offset(VTOFFSET.query.v); return o == 0 ? false : true }
  public var queryCount: Int32 { let o = _accessor.offset(VTOFFSET.query.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func query(at index: Int32) -> bpio_StatusRequestTypes? { let o = _accessor.offset(VTOFFSET.query.v); return o == 0 ? bpio_StatusRequestTypes.all : bpio_StatusRequestTypes(rawValue: _accessor.directRead(of: Int8.self, offset: _accessor.vector(at: o) + index * 1)) }
  public static func startStatusRequest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(query: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: query, at: VTOFFSET.query.p) }
  public static func endStatusRequest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createStatusRequest(
    _ fbb: inout FlatBufferBuilder,
    queryVectorOffset query: Offset = Offset()
  ) -> Offset {
    let __start = bpio_StatusRequest.startStatusRequest(&fbb)
    bpio_StatusRequest.addVectorOf(query: query, &fbb)
    return bpio_StatusRequest.endStatusRequest(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.query.p, fieldName: "query", required: false, type: ForwardOffset<Vector<bpio_StatusRequestTypes, bpio_StatusRequestTypes>>.self)
    _v.finish()
  }
}

public struct bpio_Monster: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case pos = 4
    case mana = 6
    case hp = 8
    case name = 10
    case inventory = 14
    case color = 16
    case weapons = 18
    case equippedType = 20
    case equipped = 22
    case path = 24
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var pos: bpio_Vec3? { let o = _accessor.offset(VTOFFSET.pos.v); return o == 0 ? nil : _accessor.readBuffer(of: bpio_Vec3.self, at: o) }
  public var mutablePos: bpio_Vec3_Mutable? { let o = _accessor.offset(VTOFFSET.pos.v); return o == 0 ? nil : bpio_Vec3_Mutable(_accessor.bb, o: o + _accessor.position) }
  public var mana: Int16 { let o = _accessor.offset(VTOFFSET.mana.v); return o == 0 ? 150 : _accessor.readBuffer(of: Int16.self, at: o) }
  public var hp: Int16 { let o = _accessor.offset(VTOFFSET.hp.v); return o == 0 ? 100 : _accessor.readBuffer(of: Int16.self, at: o) }
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var hasInventory: Bool { let o = _accessor.offset(VTOFFSET.inventory.v); return o == 0 ? false : true }
  public var inventoryCount: Int32 { let o = _accessor.offset(VTOFFSET.inventory.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func inventory(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.inventory.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var inventory: [UInt8] { return _accessor.getVector(at: VTOFFSET.inventory.v) ?? [] }
  public func withUnsafePointerToInventory<T>(_ body: (UnsafeRawBufferPointer) throws -> T) rethrows -> T? { return try _accessor.withUnsafePointerToSlice(at: VTOFFSET.inventory.v, body: body) }
  public var color: bpio_Color { let o = _accessor.offset(VTOFFSET.color.v); return o == 0 ? .blue : bpio_Color(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .blue }
  public var hasWeapons: Bool { let o = _accessor.offset(VTOFFSET.weapons.v); return o == 0 ? false : true }
  public var weaponsCount: Int32 { let o = _accessor.offset(VTOFFSET.weapons.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func weapons(at index: Int32) -> bpio_Weapon? { let o = _accessor.offset(VTOFFSET.weapons.v); return o == 0 ? nil : bpio_Weapon(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var equippedType: bpio_Equipment { let o = _accessor.offset(VTOFFSET.equippedType.v); return o == 0 ? .none_ : bpio_Equipment(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public func equipped<T: FlatbuffersInitializable>(type: T.Type) -> T? { let o = _accessor.offset(VTOFFSET.equipped.v); return o == 0 ? nil : _accessor.union(o) }
  public var hasPath: Bool { let o = _accessor.offset(VTOFFSET.path.v); return o == 0 ? false : true }
  public var pathCount: Int32 { let o = _accessor.offset(VTOFFSET.path.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func path(at index: Int32) -> bpio_Vec3? { let o = _accessor.offset(VTOFFSET.path.v); return o == 0 ? nil : _accessor.directRead(of: bpio_Vec3.self, offset: _accessor.vector(at: o) + index * 12) }
  public func mutablePath(at index: Int32) -> bpio_Vec3_Mutable? { let o = _accessor.offset(VTOFFSET.path.v); return o == 0 ? nil : bpio_Vec3_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 12) }
  public func withUnsafePointerToPath<T>(_ body: (UnsafeRawBufferPointer) throws -> T) rethrows -> T? { return try _accessor.withUnsafePointerToSlice(at: VTOFFSET.path.v, body: body) }
  public static func startMonster(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 11) }
  public static func add(pos: bpio_Vec3?, _ fbb: inout FlatBufferBuilder) { guard let pos = pos else { return }; fbb.create(struct: pos, position: VTOFFSET.pos.p) }
  public static func add(mana: Int16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mana, def: 150, at: VTOFFSET.mana.p) }
  public static func add(hp: Int16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hp, def: 100, at: VTOFFSET.hp.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func addVectorOf(inventory: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: inventory, at: VTOFFSET.inventory.p) }
  public static func add(color: bpio_Color, _ fbb: inout FlatBufferBuilder) { fbb.add(element: color.rawValue, def: 2, at: VTOFFSET.color.p) }
  public static func addVectorOf(weapons: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: weapons, at: VTOFFSET.weapons.p) }
  public static func add(equippedType: bpio_Equipment, _ fbb: inout FlatBufferBuilder) { fbb.add(element: equippedType.rawValue, def: 0, at: VTOFFSET.equippedType.p) }
  public static func add(equipped: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: equipped, at: VTOFFSET.equipped.p) }
  public static func addVectorOf(path: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: path, at: VTOFFSET.path.p) }
  public static func startVectorOfPath(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<bpio_Vec3>.size, elementSize: MemoryLayout<bpio_Vec3>.alignment)
  }
  public static func endMonster(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createMonster(
    _ fbb: inout FlatBufferBuilder,
    pos: bpio_Vec3? = nil,
    mana: Int16 = 150,
    hp: Int16 = 100,
    nameOffset name: Offset = Offset(),
    inventoryVectorOffset inventory: Offset = Offset(),
    color: bpio_Color = .blue,
    weaponsVectorOffset weapons: Offset = Offset(),
    equippedType: bpio_Equipment = .none_,
    equippedOffset equipped: Offset = Offset(),
    pathVectorOffset path: Offset = Offset()
  ) -> Offset {
    let __start = bpio_Monster.startMonster(&fbb)
    bpio_Monster.add(pos: pos, &fbb)
    bpio_Monster.add(mana: mana, &fbb)
    bpio_Monster.add(hp: hp, &fbb)
    bpio_Monster.add(name: name, &fbb)
    bpio_Monster.addVectorOf(inventory: inventory, &fbb)
    bpio_Monster.add(color: color, &fbb)
    bpio_Monster.addVectorOf(weapons: weapons, &fbb)
    bpio_Monster.add(equippedType: equippedType, &fbb)
    bpio_Monster.add(equipped: equipped, &fbb)
    bpio_Monster.addVectorOf(path: path, &fbb)
    return bpio_Monster.endMonster(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.pos.p, fieldName: "pos", required: false, type: bpio_Vec3.self)
    try _v.visit(field: VTOFFSET.mana.p, fieldName: "mana", required: false, type: Int16.self)
    try _v.visit(field: VTOFFSET.hp.p, fieldName: "hp", required: false, type: Int16.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.inventory.p, fieldName: "inventory", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.color.p, fieldName: "color", required: false, type: bpio_Color.self)
    try _v.visit(field: VTOFFSET.weapons.p, fieldName: "weapons", required: false, type: ForwardOffset<Vector<ForwardOffset<bpio_Weapon>, bpio_Weapon>>.self)
    try _v.visit(unionKey: VTOFFSET.equippedType.p, unionField: VTOFFSET.equipped.p, unionKeyName: "equippedType", fieldName: "equipped", required: false, completion: { (verifier, key: bpio_Equipment, pos) in
      switch key {
      case .none_:
        break // NOTE - SWIFT doesnt support none
      case .weapon:
        try ForwardOffset<bpio_Weapon>.verify(&verifier, at: pos, of: bpio_Weapon.self)
      }
    })
    try _v.visit(field: VTOFFSET.path.p, fieldName: "path", required: false, type: ForwardOffset<Vector<bpio_Vec3, bpio_Vec3>>.self)
    _v.finish()
  }
}

public struct bpio_Weapon: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case name = 4
    case damage = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var damage: Int16 { let o = _accessor.offset(VTOFFSET.damage.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int16.self, at: o) }
  public static func startWeapon(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(damage: Int16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: damage, def: 0, at: VTOFFSET.damage.p) }
  public static func endWeapon(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createWeapon(
    _ fbb: inout FlatBufferBuilder,
    nameOffset name: Offset = Offset(),
    damage: Int16 = 0
  ) -> Offset {
    let __start = bpio_Weapon.startWeapon(&fbb)
    bpio_Weapon.add(name: name, &fbb)
    bpio_Weapon.add(damage: damage, &fbb)
    return bpio_Weapon.endWeapon(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.damage.p, fieldName: "damage", required: false, type: Int16.self)
    _v.finish()
  }
}

public struct bpio_StatusResponse: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case error = 4
    case psuEnabled = 6
    case psuSetMv = 8
    case psuSetMa = 10
    case psuMeasuredMv = 12
    case psuMeasuredMa = 14
    case psuCurrentError = 16
    case pullupEnabled = 18
    case adcMv = 20
    case ioDirection = 22
    case ioValue = 24
    case diskSizeMb = 26
    case diskUsedMb = 28
    case ledCount = 30
    case versionFlatbuffersMajor = 32
    case versionFlatbuffersMinor = 34
    case versionHardwareMajor = 36
    case versionHardwareMinor = 38
    case versionFirmwareMajor = 40
    case versionFirmwareMinor = 42
    case versionFirmwareGitHash = 44
    case versionFirmwareDate = 46
    case modesAvailable = 48
    case modeCurrent = 50
    case modePinLabels = 52
    case modeBitorderMsb = 54
    case modeMaxPacketSize = 56
    case modeMaxWrite = 58
    case modeMaxRead = 60
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var error: String? { let o = _accessor.offset(VTOFFSET.error.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var errorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.error.v) }
  public var psuEnabled: Bool { let o = _accessor.offset(VTOFFSET.psuEnabled.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var psuSetMv: UInt32 { let o = _accessor.offset(VTOFFSET.psuSetMv.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var psuSetMa: UInt32 { let o = _accessor.offset(VTOFFSET.psuSetMa.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var psuMeasuredMv: UInt32 { let o = _accessor.offset(VTOFFSET.psuMeasuredMv.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var psuMeasuredMa: UInt32 { let o = _accessor.offset(VTOFFSET.psuMeasuredMa.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var psuCurrentError: Bool { let o = _accessor.offset(VTOFFSET.psuCurrentError.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var pullupEnabled: Bool { let o = _accessor.offset(VTOFFSET.pullupEnabled.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var hasAdcMv: Bool { let o = _accessor.offset(VTOFFSET.adcMv.v); return o == 0 ? false : true }
  public var adcMvCount: Int32 { let o = _accessor.offset(VTOFFSET.adcMv.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func adcMv(at index: Int32) -> UInt32 { let o = _accessor.offset(VTOFFSET.adcMv.v); return o == 0 ? 0 : _accessor.directRead(of: UInt32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var adcMv: [UInt32] { return _accessor.getVector(at: VTOFFSET.adcMv.v) ?? [] }
  public func withUnsafePointerToAdcMv<T>(_ body: (UnsafeRawBufferPointer) throws -> T) rethrows -> T? { return try _accessor.withUnsafePointerToSlice(at: VTOFFSET.adcMv.v, body: body) }
  public var ioDirection: UInt8 { let o = _accessor.offset(VTOFFSET.ioDirection.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var ioValue: UInt8 { let o = _accessor.offset(VTOFFSET.ioValue.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var diskSizeMb: Float32 { let o = _accessor.offset(VTOFFSET.diskSizeMb.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var diskUsedMb: Float32 { let o = _accessor.offset(VTOFFSET.diskUsedMb.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var ledCount: UInt8 { let o = _accessor.offset(VTOFFSET.ledCount.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var versionFlatbuffersMajor: UInt8 { let o = _accessor.offset(VTOFFSET.versionFlatbuffersMajor.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var versionFlatbuffersMinor: UInt16 { let o = _accessor.offset(VTOFFSET.versionFlatbuffersMinor.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  public var versionHardwareMajor: UInt8 { let o = _accessor.offset(VTOFFSET.versionHardwareMajor.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var versionHardwareMinor: UInt8 { let o = _accessor.offset(VTOFFSET.versionHardwareMinor.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var versionFirmwareMajor: UInt8 { let o = _accessor.offset(VTOFFSET.versionFirmwareMajor.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var versionFirmwareMinor: UInt8 { let o = _accessor.offset(VTOFFSET.versionFirmwareMinor.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var versionFirmwareGitHash: String? { let o = _accessor.offset(VTOFFSET.versionFirmwareGitHash.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var versionFirmwareGitHashSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.versionFirmwareGitHash.v) }
  public var versionFirmwareDate: String? { let o = _accessor.offset(VTOFFSET.versionFirmwareDate.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var versionFirmwareDateSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.versionFirmwareDate.v) }
  public var hasModesAvailable: Bool { let o = _accessor.offset(VTOFFSET.modesAvailable.v); return o == 0 ? false : true }
  public var modesAvailableCount: Int32 { let o = _accessor.offset(VTOFFSET.modesAvailable.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func modesAvailable(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.modesAvailable.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public var modeCurrent: String? { let o = _accessor.offset(VTOFFSET.modeCurrent.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var modeCurrentSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.modeCurrent.v) }
  public var hasModePinLabels: Bool { let o = _accessor.offset(VTOFFSET.modePinLabels.v); return o == 0 ? false : true }
  public var modePinLabelsCount: Int32 { let o = _accessor.offset(VTOFFSET.modePinLabels.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func modePinLabels(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.modePinLabels.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public var modeBitorderMsb: Bool { let o = _accessor.offset(VTOFFSET.modeBitorderMsb.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var modeMaxPacketSize: UInt32 { let o = _accessor.offset(VTOFFSET.modeMaxPacketSize.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var modeMaxWrite: UInt32 { let o = _accessor.offset(VTOFFSET.modeMaxWrite.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var modeMaxRead: UInt32 { let o = _accessor.offset(VTOFFSET.modeMaxRead.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public static func startStatusResponse(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 29) }
  public static func add(error: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: error, at: VTOFFSET.error.p) }
  public static func add(psuEnabled: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: psuEnabled, def: false,
   at: VTOFFSET.psuEnabled.p) }
  public static func add(psuSetMv: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: psuSetMv, def: 0, at: VTOFFSET.psuSetMv.p) }
  public static func add(psuSetMa: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: psuSetMa, def: 0, at: VTOFFSET.psuSetMa.p) }
  public static func add(psuMeasuredMv: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: psuMeasuredMv, def: 0, at: VTOFFSET.psuMeasuredMv.p) }
  public static func add(psuMeasuredMa: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: psuMeasuredMa, def: 0, at: VTOFFSET.psuMeasuredMa.p) }
  public static func add(psuCurrentError: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: psuCurrentError, def: false,
   at: VTOFFSET.psuCurrentError.p) }
  public static func add(pullupEnabled: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: pullupEnabled, def: false,
   at: VTOFFSET.pullupEnabled.p) }
  public static func addVectorOf(adcMv: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: adcMv, at: VTOFFSET.adcMv.p) }
  public static func add(ioDirection: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ioDirection, def: 0, at: VTOFFSET.ioDirection.p) }
  public static func add(ioValue: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ioValue, def: 0, at: VTOFFSET.ioValue.p) }
  public static func add(diskSizeMb: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: diskSizeMb, def: 0.0, at: VTOFFSET.diskSizeMb.p) }
  public static func add(diskUsedMb: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: diskUsedMb, def: 0.0, at: VTOFFSET.diskUsedMb.p) }
  public static func add(ledCount: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ledCount, def: 0, at: VTOFFSET.ledCount.p) }
  public static func add(versionFlatbuffersMajor: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: versionFlatbuffersMajor, def: 0, at: VTOFFSET.versionFlatbuffersMajor.p) }
  public static func add(versionFlatbuffersMinor: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: versionFlatbuffersMinor, def: 0, at: VTOFFSET.versionFlatbuffersMinor.p) }
  public static func add(versionHardwareMajor: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: versionHardwareMajor, def: 0, at: VTOFFSET.versionHardwareMajor.p) }
  public static func add(versionHardwareMinor: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: versionHardwareMinor, def: 0, at: VTOFFSET.versionHardwareMinor.p) }
  public static func add(versionFirmwareMajor: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: versionFirmwareMajor, def: 0, at: VTOFFSET.versionFirmwareMajor.p) }
  public static func add(versionFirmwareMinor: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: versionFirmwareMinor, def: 0, at: VTOFFSET.versionFirmwareMinor.p) }
  public static func add(versionFirmwareGitHash: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: versionFirmwareGitHash, at: VTOFFSET.versionFirmwareGitHash.p) }
  public static func add(versionFirmwareDate: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: versionFirmwareDate, at: VTOFFSET.versionFirmwareDate.p) }
  public static func addVectorOf(modesAvailable: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: modesAvailable, at: VTOFFSET.modesAvailable.p) }
  public static func add(modeCurrent: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: modeCurrent, at: VTOFFSET.modeCurrent.p) }
  public static func addVectorOf(modePinLabels: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: modePinLabels, at: VTOFFSET.modePinLabels.p) }
  public static func add(modeBitorderMsb: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: modeBitorderMsb, def: false,
   at: VTOFFSET.modeBitorderMsb.p) }
  public static func add(modeMaxPacketSize: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: modeMaxPacketSize, def: 0, at: VTOFFSET.modeMaxPacketSize.p) }
  public static func add(modeMaxWrite: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: modeMaxWrite, def: 0, at: VTOFFSET.modeMaxWrite.p) }
  public static func add(modeMaxRead: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: modeMaxRead, def: 0, at: VTOFFSET.modeMaxRead.p) }
  public static func endStatusResponse(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createStatusResponse(
    _ fbb: inout FlatBufferBuilder,
    errorOffset error: Offset = Offset(),
    psuEnabled: Bool = false,
    psuSetMv: UInt32 = 0,
    psuSetMa: UInt32 = 0,
    psuMeasuredMv: UInt32 = 0,
    psuMeasuredMa: UInt32 = 0,
    psuCurrentError: Bool = false,
    pullupEnabled: Bool = false,
    adcMvVectorOffset adcMv: Offset = Offset(),
    ioDirection: UInt8 = 0,
    ioValue: UInt8 = 0,
    diskSizeMb: Float32 = 0.0,
    diskUsedMb: Float32 = 0.0,
    ledCount: UInt8 = 0,
    versionFlatbuffersMajor: UInt8 = 0,
    versionFlatbuffersMinor: UInt16 = 0,
    versionHardwareMajor: UInt8 = 0,
    versionHardwareMinor: UInt8 = 0,
    versionFirmwareMajor: UInt8 = 0,
    versionFirmwareMinor: UInt8 = 0,
    versionFirmwareGitHashOffset versionFirmwareGitHash: Offset = Offset(),
    versionFirmwareDateOffset versionFirmwareDate: Offset = Offset(),
    modesAvailableVectorOffset modesAvailable: Offset = Offset(),
    modeCurrentOffset modeCurrent: Offset = Offset(),
    modePinLabelsVectorOffset modePinLabels: Offset = Offset(),
    modeBitorderMsb: Bool = false,
    modeMaxPacketSize: UInt32 = 0,
    modeMaxWrite: UInt32 = 0,
    modeMaxRead: UInt32 = 0
  ) -> Offset {
    let __start = bpio_StatusResponse.startStatusResponse(&fbb)
    bpio_StatusResponse.add(error: error, &fbb)
    bpio_StatusResponse.add(psuEnabled: psuEnabled, &fbb)
    bpio_StatusResponse.add(psuSetMv: psuSetMv, &fbb)
    bpio_StatusResponse.add(psuSetMa: psuSetMa, &fbb)
    bpio_StatusResponse.add(psuMeasuredMv: psuMeasuredMv, &fbb)
    bpio_StatusResponse.add(psuMeasuredMa: psuMeasuredMa, &fbb)
    bpio_StatusResponse.add(psuCurrentError: psuCurrentError, &fbb)
    bpio_StatusResponse.add(pullupEnabled: pullupEnabled, &fbb)
    bpio_StatusResponse.addVectorOf(adcMv: adcMv, &fbb)
    bpio_StatusResponse.add(ioDirection: ioDirection, &fbb)
    bpio_StatusResponse.add(ioValue: ioValue, &fbb)
    bpio_StatusResponse.add(diskSizeMb: diskSizeMb, &fbb)
    bpio_StatusResponse.add(diskUsedMb: diskUsedMb, &fbb)
    bpio_StatusResponse.add(ledCount: ledCount, &fbb)
    bpio_StatusResponse.add(versionFlatbuffersMajor: versionFlatbuffersMajor, &fbb)
    bpio_StatusResponse.add(versionFlatbuffersMinor: versionFlatbuffersMinor, &fbb)
    bpio_StatusResponse.add(versionHardwareMajor: versionHardwareMajor, &fbb)
    bpio_StatusResponse.add(versionHardwareMinor: versionHardwareMinor, &fbb)
    bpio_StatusResponse.add(versionFirmwareMajor: versionFirmwareMajor, &fbb)
    bpio_StatusResponse.add(versionFirmwareMinor: versionFirmwareMinor, &fbb)
    bpio_StatusResponse.add(versionFirmwareGitHash: versionFirmwareGitHash, &fbb)
    bpio_StatusResponse.add(versionFirmwareDate: versionFirmwareDate, &fbb)
    bpio_StatusResponse.addVectorOf(modesAvailable: modesAvailable, &fbb)
    bpio_StatusResponse.add(modeCurrent: modeCurrent, &fbb)
    bpio_StatusResponse.addVectorOf(modePinLabels: modePinLabels, &fbb)
    bpio_StatusResponse.add(modeBitorderMsb: modeBitorderMsb, &fbb)
    bpio_StatusResponse.add(modeMaxPacketSize: modeMaxPacketSize, &fbb)
    bpio_StatusResponse.add(modeMaxWrite: modeMaxWrite, &fbb)
    bpio_StatusResponse.add(modeMaxRead: modeMaxRead, &fbb)
    return bpio_StatusResponse.endStatusResponse(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.error.p, fieldName: "error", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.psuEnabled.p, fieldName: "psuEnabled", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.psuSetMv.p, fieldName: "psuSetMv", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.psuSetMa.p, fieldName: "psuSetMa", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.psuMeasuredMv.p, fieldName: "psuMeasuredMv", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.psuMeasuredMa.p, fieldName: "psuMeasuredMa", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.psuCurrentError.p, fieldName: "psuCurrentError", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.pullupEnabled.p, fieldName: "pullupEnabled", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.adcMv.p, fieldName: "adcMv", required: false, type: ForwardOffset<Vector<UInt32, UInt32>>.self)
    try _v.visit(field: VTOFFSET.ioDirection.p, fieldName: "ioDirection", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.ioValue.p, fieldName: "ioValue", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.diskSizeMb.p, fieldName: "diskSizeMb", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.diskUsedMb.p, fieldName: "diskUsedMb", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.ledCount.p, fieldName: "ledCount", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.versionFlatbuffersMajor.p, fieldName: "versionFlatbuffersMajor", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.versionFlatbuffersMinor.p, fieldName: "versionFlatbuffersMinor", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.versionHardwareMajor.p, fieldName: "versionHardwareMajor", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.versionHardwareMinor.p, fieldName: "versionHardwareMinor", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.versionFirmwareMajor.p, fieldName: "versionFirmwareMajor", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.versionFirmwareMinor.p, fieldName: "versionFirmwareMinor", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.versionFirmwareGitHash.p, fieldName: "versionFirmwareGitHash", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.versionFirmwareDate.p, fieldName: "versionFirmwareDate", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.modesAvailable.p, fieldName: "modesAvailable", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.modeCurrent.p, fieldName: "modeCurrent", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.modePinLabels.p, fieldName: "modePinLabels", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.modeBitorderMsb.p, fieldName: "modeBitorderMsb", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.modeMaxPacketSize.p, fieldName: "modeMaxPacketSize", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.modeMaxWrite.p, fieldName: "modeMaxWrite", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.modeMaxRead.p, fieldName: "modeMaxRead", required: false, type: UInt32.self)
    _v.finish()
  }
}

public struct bpio_ModeConfiguration: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case speed = 4
    case dataBits = 6
    case parity = 8
    case stopBits = 10
    case flowControl = 12
    case signalInversion = 14
    case submode = 16
    case txModulation = 18
    case rxSensor = 20
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var speed: UInt32 { let o = _accessor.offset(VTOFFSET.speed.v); return o == 0 ? 20000 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var dataBits: UInt8 { let o = _accessor.offset(VTOFFSET.dataBits.v); return o == 0 ? 8 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var parity: Bool { let o = _accessor.offset(VTOFFSET.parity.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var stopBits: UInt8 { let o = _accessor.offset(VTOFFSET.stopBits.v); return o == 0 ? 1 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var flowControl: Bool { let o = _accessor.offset(VTOFFSET.flowControl.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var signalInversion: Bool { let o = _accessor.offset(VTOFFSET.signalInversion.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var submode: UInt8 { let o = _accessor.offset(VTOFFSET.submode.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var txModulation: UInt32 { let o = _accessor.offset(VTOFFSET.txModulation.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var rxSensor: UInt8 { let o = _accessor.offset(VTOFFSET.rxSensor.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public static func startModeConfiguration(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 9) }
  public static func add(speed: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: speed, def: 20000, at: VTOFFSET.speed.p) }
  public static func add(dataBits: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataBits, def: 8, at: VTOFFSET.dataBits.p) }
  public static func add(parity: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: parity, def: false,
   at: VTOFFSET.parity.p) }
  public static func add(stopBits: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: stopBits, def: 1, at: VTOFFSET.stopBits.p) }
  public static func add(flowControl: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: flowControl, def: false,
   at: VTOFFSET.flowControl.p) }
  public static func add(signalInversion: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: signalInversion, def: false,
   at: VTOFFSET.signalInversion.p) }
  public static func add(submode: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: submode, def: 0, at: VTOFFSET.submode.p) }
  public static func add(txModulation: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: txModulation, def: 0, at: VTOFFSET.txModulation.p) }
  public static func add(rxSensor: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: rxSensor, def: 0, at: VTOFFSET.rxSensor.p) }
  public static func endModeConfiguration(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createModeConfiguration(
    _ fbb: inout FlatBufferBuilder,
    speed: UInt32 = 20000,
    dataBits: UInt8 = 8,
    parity: Bool = false,
    stopBits: UInt8 = 1,
    flowControl: Bool = false,
    signalInversion: Bool = false,
    submode: UInt8 = 0,
    txModulation: UInt32 = 0,
    rxSensor: UInt8 = 0
  ) -> Offset {
    let __start = bpio_ModeConfiguration.startModeConfiguration(&fbb)
    bpio_ModeConfiguration.add(speed: speed, &fbb)
    bpio_ModeConfiguration.add(dataBits: dataBits, &fbb)
    bpio_ModeConfiguration.add(parity: parity, &fbb)
    bpio_ModeConfiguration.add(stopBits: stopBits, &fbb)
    bpio_ModeConfiguration.add(flowControl: flowControl, &fbb)
    bpio_ModeConfiguration.add(signalInversion: signalInversion, &fbb)
    bpio_ModeConfiguration.add(submode: submode, &fbb)
    bpio_ModeConfiguration.add(txModulation: txModulation, &fbb)
    bpio_ModeConfiguration.add(rxSensor: rxSensor, &fbb)
    return bpio_ModeConfiguration.endModeConfiguration(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.speed.p, fieldName: "speed", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.dataBits.p, fieldName: "dataBits", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.parity.p, fieldName: "parity", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.stopBits.p, fieldName: "stopBits", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.flowControl.p, fieldName: "flowControl", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.signalInversion.p, fieldName: "signalInversion", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.submode.p, fieldName: "submode", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.txModulation.p, fieldName: "txModulation", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.rxSensor.p, fieldName: "rxSensor", required: false, type: UInt8.self)
    _v.finish()
  }
}

public struct bpio_ConfigurationRequest: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case mode = 4
    case modeConfiguration = 6
    case modeBitorderMsb = 8
    case modeBitorderLsb = 10
    case psuDisable = 12
    case psuEnable = 14
    case psuSetMv = 16
    case psuSetMa = 18
    case pullupDisable = 20
    case pullupEnable = 22
    case ioDirectionMask = 24
    case ioDirection = 26
    case ioValueMask = 28
    case ioValue = 30
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var mode: String? { let o = _accessor.offset(VTOFFSET.mode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var modeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.mode.v) }
  public var modeConfiguration: bpio_ModeConfiguration? { let o = _accessor.offset(VTOFFSET.modeConfiguration.v); return o == 0 ? nil : bpio_ModeConfiguration(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public var modeBitorderMsb: Bool { let o = _accessor.offset(VTOFFSET.modeBitorderMsb.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var modeBitorderLsb: Bool { let o = _accessor.offset(VTOFFSET.modeBitorderLsb.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var psuDisable: Bool { let o = _accessor.offset(VTOFFSET.psuDisable.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var psuEnable: Bool { let o = _accessor.offset(VTOFFSET.psuEnable.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var psuSetMv: UInt32 { let o = _accessor.offset(VTOFFSET.psuSetMv.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var psuSetMa: UInt16 { let o = _accessor.offset(VTOFFSET.psuSetMa.v); return o == 0 ? 300 : _accessor.readBuffer(of: UInt16.self, at: o) }
  public var pullupDisable: Bool { let o = _accessor.offset(VTOFFSET.pullupDisable.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var pullupEnable: Bool { let o = _accessor.offset(VTOFFSET.pullupEnable.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var ioDirectionMask: UInt8 { let o = _accessor.offset(VTOFFSET.ioDirectionMask.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var ioDirection: UInt8 { let o = _accessor.offset(VTOFFSET.ioDirection.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var ioValueMask: UInt8 { let o = _accessor.offset(VTOFFSET.ioValueMask.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var ioValue: UInt8 { let o = _accessor.offset(VTOFFSET.ioValue.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public static func startConfigurationRequest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 14) }
  public static func add(mode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: mode, at: VTOFFSET.mode.p) }
  public static func add(modeConfiguration: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: modeConfiguration, at: VTOFFSET.modeConfiguration.p) }
  public static func add(modeBitorderMsb: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: modeBitorderMsb, def: false,
   at: VTOFFSET.modeBitorderMsb.p) }
  public static func add(modeBitorderLsb: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: modeBitorderLsb, def: false,
   at: VTOFFSET.modeBitorderLsb.p) }
  public static func add(psuDisable: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: psuDisable, def: false,
   at: VTOFFSET.psuDisable.p) }
  public static func add(psuEnable: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: psuEnable, def: false,
   at: VTOFFSET.psuEnable.p) }
  public static func add(psuSetMv: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: psuSetMv, def: 0, at: VTOFFSET.psuSetMv.p) }
  public static func add(psuSetMa: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: psuSetMa, def: 300, at: VTOFFSET.psuSetMa.p) }
  public static func add(pullupDisable: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: pullupDisable, def: false,
   at: VTOFFSET.pullupDisable.p) }
  public static func add(pullupEnable: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: pullupEnable, def: false,
   at: VTOFFSET.pullupEnable.p) }
  public static func add(ioDirectionMask: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ioDirectionMask, def: 0, at: VTOFFSET.ioDirectionMask.p) }
  public static func add(ioDirection: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ioDirection, def: 0, at: VTOFFSET.ioDirection.p) }
  public static func add(ioValueMask: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ioValueMask, def: 0, at: VTOFFSET.ioValueMask.p) }
  public static func add(ioValue: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ioValue, def: 0, at: VTOFFSET.ioValue.p) }
  public static func endConfigurationRequest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createConfigurationRequest(
    _ fbb: inout FlatBufferBuilder,
    modeOffset mode: Offset = Offset(),
    modeConfigurationOffset modeConfiguration: Offset = Offset(),
    modeBitorderMsb: Bool = false,
    modeBitorderLsb: Bool = false,
    psuDisable: Bool = false,
    psuEnable: Bool = false,
    psuSetMv: UInt32 = 0,
    psuSetMa: UInt16 = 300,
    pullupDisable: Bool = false,
    pullupEnable: Bool = false,
    ioDirectionMask: UInt8 = 0,
    ioDirection: UInt8 = 0,
    ioValueMask: UInt8 = 0,
    ioValue: UInt8 = 0
  ) -> Offset {
    let __start = bpio_ConfigurationRequest.startConfigurationRequest(&fbb)
    bpio_ConfigurationRequest.add(mode: mode, &fbb)
    bpio_ConfigurationRequest.add(modeConfiguration: modeConfiguration, &fbb)
    bpio_ConfigurationRequest.add(modeBitorderMsb: modeBitorderMsb, &fbb)
    bpio_ConfigurationRequest.add(modeBitorderLsb: modeBitorderLsb, &fbb)
    bpio_ConfigurationRequest.add(psuDisable: psuDisable, &fbb)
    bpio_ConfigurationRequest.add(psuEnable: psuEnable, &fbb)
    bpio_ConfigurationRequest.add(psuSetMv: psuSetMv, &fbb)
    bpio_ConfigurationRequest.add(psuSetMa: psuSetMa, &fbb)
    bpio_ConfigurationRequest.add(pullupDisable: pullupDisable, &fbb)
    bpio_ConfigurationRequest.add(pullupEnable: pullupEnable, &fbb)
    bpio_ConfigurationRequest.add(ioDirectionMask: ioDirectionMask, &fbb)
    bpio_ConfigurationRequest.add(ioDirection: ioDirection, &fbb)
    bpio_ConfigurationRequest.add(ioValueMask: ioValueMask, &fbb)
    bpio_ConfigurationRequest.add(ioValue: ioValue, &fbb)
    return bpio_ConfigurationRequest.endConfigurationRequest(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.mode.p, fieldName: "mode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.modeConfiguration.p, fieldName: "modeConfiguration", required: false, type: ForwardOffset<bpio_ModeConfiguration>.self)
    try _v.visit(field: VTOFFSET.modeBitorderMsb.p, fieldName: "modeBitorderMsb", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.modeBitorderLsb.p, fieldName: "modeBitorderLsb", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.psuDisable.p, fieldName: "psuDisable", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.psuEnable.p, fieldName: "psuEnable", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.psuSetMv.p, fieldName: "psuSetMv", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.psuSetMa.p, fieldName: "psuSetMa", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.pullupDisable.p, fieldName: "pullupDisable", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.pullupEnable.p, fieldName: "pullupEnable", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.ioDirectionMask.p, fieldName: "ioDirectionMask", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.ioDirection.p, fieldName: "ioDirection", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.ioValueMask.p, fieldName: "ioValueMask", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.ioValue.p, fieldName: "ioValue", required: false, type: UInt8.self)
    _v.finish()
  }
}

public struct bpio_ConfigurationResponse: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case error = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var error: String? { let o = _accessor.offset(VTOFFSET.error.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var errorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.error.v) }
  public static func startConfigurationResponse(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(error: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: error, at: VTOFFSET.error.p) }
  public static func endConfigurationResponse(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createConfigurationResponse(
    _ fbb: inout FlatBufferBuilder,
    errorOffset error: Offset = Offset()
  ) -> Offset {
    let __start = bpio_ConfigurationResponse.startConfigurationResponse(&fbb)
    bpio_ConfigurationResponse.add(error: error, &fbb)
    return bpio_ConfigurationResponse.endConfigurationResponse(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.error.p, fieldName: "error", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct bpio_DataRequest: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case startMain = 4
    case startAlt = 6
    case dataWrite = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var startMain: Bool { let o = _accessor.offset(VTOFFSET.startMain.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var startAlt: Bool { let o = _accessor.offset(VTOFFSET.startAlt.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var hasDataWrite: Bool { let o = _accessor.offset(VTOFFSET.dataWrite.v); return o == 0 ? false : true }
  public var dataWriteCount: Int32 { let o = _accessor.offset(VTOFFSET.dataWrite.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func dataWrite(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.dataWrite.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var dataWrite: [UInt8] { return _accessor.getVector(at: VTOFFSET.dataWrite.v) ?? [] }
  public func withUnsafePointerToDataWrite<T>(_ body: (UnsafeRawBufferPointer) throws -> T) rethrows -> T? { return try _accessor.withUnsafePointerToSlice(at: VTOFFSET.dataWrite.v, body: body) }
  public static func startDataRequest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(startMain: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: startMain, def: false,
   at: VTOFFSET.startMain.p) }
  public static func add(startAlt: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: startAlt, def: false,
   at: VTOFFSET.startAlt.p) }
  public static func addVectorOf(dataWrite: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: dataWrite, at: VTOFFSET.dataWrite.p) }
  public static func endDataRequest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createDataRequest(
    _ fbb: inout FlatBufferBuilder,
    startMain: Bool = false,
    startAlt: Bool = false,
    dataWriteVectorOffset dataWrite: Offset = Offset()
  ) -> Offset {
    let __start = bpio_DataRequest.startDataRequest(&fbb)
    bpio_DataRequest.add(startMain: startMain, &fbb)
    bpio_DataRequest.add(startAlt: startAlt, &fbb)
    bpio_DataRequest.addVectorOf(dataWrite: dataWrite, &fbb)
    return bpio_DataRequest.endDataRequest(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.startMain.p, fieldName: "startMain", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.startAlt.p, fieldName: "startAlt", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.dataWrite.p, fieldName: "dataWrite", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

public struct bpio_DataResponse: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case error = 4
    case dataRead = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var error: String? { let o = _accessor.offset(VTOFFSET.error.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var errorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.error.v) }
  public var hasDataRead: Bool { let o = _accessor.offset(VTOFFSET.dataRead.v); return o == 0 ? false : true }
  public var dataReadCount: Int32 { let o = _accessor.offset(VTOFFSET.dataRead.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func dataRead(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.dataRead.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var dataRead: [UInt8] { return _accessor.getVector(at: VTOFFSET.dataRead.v) ?? [] }
  public func withUnsafePointerToDataRead<T>(_ body: (UnsafeRawBufferPointer) throws -> T) rethrows -> T? { return try _accessor.withUnsafePointerToSlice(at: VTOFFSET.dataRead.v, body: body) }
  public static func startDataResponse(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(error: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: error, at: VTOFFSET.error.p) }
  public static func addVectorOf(dataRead: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: dataRead, at: VTOFFSET.dataRead.p) }
  public static func endDataResponse(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createDataResponse(
    _ fbb: inout FlatBufferBuilder,
    errorOffset error: Offset = Offset(),
    dataReadVectorOffset dataRead: Offset = Offset()
  ) -> Offset {
    let __start = bpio_DataResponse.startDataResponse(&fbb)
    bpio_DataResponse.add(error: error, &fbb)
    bpio_DataResponse.addVectorOf(dataRead: dataRead, &fbb)
    return bpio_DataResponse.endDataResponse(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.error.p, fieldName: "error", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataRead.p, fieldName: "dataRead", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

public struct bpio_ErrorResponse: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case error = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var error: String? { let o = _accessor.offset(VTOFFSET.error.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var errorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.error.v) }
  public static func startErrorResponse(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(error: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: error, at: VTOFFSET.error.p) }
  public static func endErrorResponse(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createErrorResponse(
    _ fbb: inout FlatBufferBuilder,
    errorOffset error: Offset = Offset()
  ) -> Offset {
    let __start = bpio_ErrorResponse.startErrorResponse(&fbb)
    bpio_ErrorResponse.add(error: error, &fbb)
    return bpio_ErrorResponse.endErrorResponse(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.error.p, fieldName: "error", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct bpio_RequestPacket: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case versionMajor = 4
    case minimumVersionMinor = 6
    case contentsType = 8
    case contents = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var versionMajor: UInt8 { let o = _accessor.offset(VTOFFSET.versionMajor.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var minimumVersionMinor: UInt16 { let o = _accessor.offset(VTOFFSET.minimumVersionMinor.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  public var contentsType: bpio_RequestPacketContents { let o = _accessor.offset(VTOFFSET.contentsType.v); return o == 0 ? .none_ : bpio_RequestPacketContents(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public func contents<T: FlatbuffersInitializable>(type: T.Type) -> T? { let o = _accessor.offset(VTOFFSET.contents.v); return o == 0 ? nil : _accessor.union(o) }
  public static func startRequestPacket(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(versionMajor: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: versionMajor, def: 0, at: VTOFFSET.versionMajor.p) }
  public static func add(minimumVersionMinor: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: minimumVersionMinor, def: 0, at: VTOFFSET.minimumVersionMinor.p) }
  public static func add(contentsType: bpio_RequestPacketContents, _ fbb: inout FlatBufferBuilder) { fbb.add(element: contentsType.rawValue, def: 0, at: VTOFFSET.contentsType.p) }
  public static func add(contents: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: contents, at: VTOFFSET.contents.p) }
  public static func endRequestPacket(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRequestPacket(
    _ fbb: inout FlatBufferBuilder,
    versionMajor: UInt8 = 0,
    minimumVersionMinor: UInt16 = 0,
    contentsType: bpio_RequestPacketContents = .none_,
    contentsOffset contents: Offset = Offset()
  ) -> Offset {
    let __start = bpio_RequestPacket.startRequestPacket(&fbb)
    bpio_RequestPacket.add(versionMajor: versionMajor, &fbb)
    bpio_RequestPacket.add(minimumVersionMinor: minimumVersionMinor, &fbb)
    bpio_RequestPacket.add(contentsType: contentsType, &fbb)
    bpio_RequestPacket.add(contents: contents, &fbb)
    return bpio_RequestPacket.endRequestPacket(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.versionMajor.p, fieldName: "versionMajor", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.minimumVersionMinor.p, fieldName: "minimumVersionMinor", required: false, type: UInt16.self)
    try _v.visit(unionKey: VTOFFSET.contentsType.p, unionField: VTOFFSET.contents.p, unionKeyName: "contentsType", fieldName: "contents", required: false, completion: { (verifier, key: bpio_RequestPacketContents, pos) in
      switch key {
      case .none_:
        break // NOTE - SWIFT doesnt support none
      case .monster:
        try ForwardOffset<bpio_Monster>.verify(&verifier, at: pos, of: bpio_Monster.self)
      case .statusrequest:
        try ForwardOffset<bpio_StatusRequest>.verify(&verifier, at: pos, of: bpio_StatusRequest.self)
      case .configurationrequest:
        try ForwardOffset<bpio_ConfigurationRequest>.verify(&verifier, at: pos, of: bpio_ConfigurationRequest.self)
      case .datarequest:
        try ForwardOffset<bpio_DataRequest>.verify(&verifier, at: pos, of: bpio_DataRequest.self)
      }
    })
    _v.finish()
  }
}

public struct bpio_ResponsePacket: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case error = 4
    case contentsType = 6
    case contents = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var error: String? { let o = _accessor.offset(VTOFFSET.error.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var errorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.error.v) }
  public var contentsType: bpio_ResponsePacketContents { let o = _accessor.offset(VTOFFSET.contentsType.v); return o == 0 ? .none_ : bpio_ResponsePacketContents(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public func contents<T: FlatbuffersInitializable>(type: T.Type) -> T? { let o = _accessor.offset(VTOFFSET.contents.v); return o == 0 ? nil : _accessor.union(o) }
  public static func startResponsePacket(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(error: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: error, at: VTOFFSET.error.p) }
  public static func add(contentsType: bpio_ResponsePacketContents, _ fbb: inout FlatBufferBuilder) { fbb.add(element: contentsType.rawValue, def: 0, at: VTOFFSET.contentsType.p) }
  public static func add(contents: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: contents, at: VTOFFSET.contents.p) }
  public static func endResponsePacket(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createResponsePacket(
    _ fbb: inout FlatBufferBuilder,
    errorOffset error: Offset = Offset(),
    contentsType: bpio_ResponsePacketContents = .none_,
    contentsOffset contents: Offset = Offset()
  ) -> Offset {
    let __start = bpio_ResponsePacket.startResponsePacket(&fbb)
    bpio_ResponsePacket.add(error: error, &fbb)
    bpio_ResponsePacket.add(contentsType: contentsType, &fbb)
    bpio_ResponsePacket.add(contents: contents, &fbb)
    return bpio_ResponsePacket.endResponsePacket(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.error.p, fieldName: "error", required: false, type: ForwardOffset<String>.self)
    try _v.visit(unionKey: VTOFFSET.contentsType.p, unionField: VTOFFSET.contents.p, unionKeyName: "contentsType", fieldName: "contents", required: false, completion: { (verifier, key: bpio_ResponsePacketContents, pos) in
      switch key {
      case .none_:
        break // NOTE - SWIFT doesnt support none
      case .errorresponse:
        try ForwardOffset<bpio_ErrorResponse>.verify(&verifier, at: pos, of: bpio_ErrorResponse.self)
      case .monster:
        try ForwardOffset<bpio_Monster>.verify(&verifier, at: pos, of: bpio_Monster.self)
      case .configurationresponse:
        try ForwardOffset<bpio_ConfigurationResponse>.verify(&verifier, at: pos, of: bpio_ConfigurationResponse.self)
      case .statusresponse:
        try ForwardOffset<bpio_StatusResponse>.verify(&verifier, at: pos, of: bpio_StatusResponse.self)
      case .dataresponse:
        try ForwardOffset<bpio_DataResponse>.verify(&verifier, at: pos, of: bpio_DataResponse.self)
      }
    })
    _v.finish()
  }
}

