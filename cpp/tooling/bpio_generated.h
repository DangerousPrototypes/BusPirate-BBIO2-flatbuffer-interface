// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BPIO_BPIO_H_
#define FLATBUFFERS_GENERATED_BPIO_BPIO_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace bpio {

struct StatusRequest;
struct StatusRequestBuilder;

struct Vec3;

struct Monster;
struct MonsterBuilder;

struct Weapon;
struct WeaponBuilder;

struct StatusResponse;
struct StatusResponseBuilder;

struct ModeConfiguration;
struct ModeConfigurationBuilder;

struct ConfigurationRequest;
struct ConfigurationRequestBuilder;

struct ConfigurationResponse;
struct ConfigurationResponseBuilder;

struct DataRequest;
struct DataRequestBuilder;

struct DataResponse;
struct DataResponseBuilder;

struct ErrorResponse;
struct ErrorResponseBuilder;

struct RequestPacket;
struct RequestPacketBuilder;

struct ResponsePacket;
struct ResponsePacketBuilder;

enum StatusRequestTypes : int8_t {
  StatusRequestTypes_All = 0,
  StatusRequestTypes_Version = 1,
  StatusRequestTypes_Mode = 2,
  StatusRequestTypes_Pullup = 3,
  StatusRequestTypes_PSU = 4,
  StatusRequestTypes_ADC = 5,
  StatusRequestTypes_IO = 6,
  StatusRequestTypes_Disk = 7,
  StatusRequestTypes_LED = 8,
  StatusRequestTypes_MIN = StatusRequestTypes_All,
  StatusRequestTypes_MAX = StatusRequestTypes_LED
};

inline const StatusRequestTypes (&EnumValuesStatusRequestTypes())[9] {
  static const StatusRequestTypes values[] = {
    StatusRequestTypes_All,
    StatusRequestTypes_Version,
    StatusRequestTypes_Mode,
    StatusRequestTypes_Pullup,
    StatusRequestTypes_PSU,
    StatusRequestTypes_ADC,
    StatusRequestTypes_IO,
    StatusRequestTypes_Disk,
    StatusRequestTypes_LED
  };
  return values;
}

inline const char * const *EnumNamesStatusRequestTypes() {
  static const char * const names[10] = {
    "All",
    "Version",
    "Mode",
    "Pullup",
    "PSU",
    "ADC",
    "IO",
    "Disk",
    "LED",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatusRequestTypes(StatusRequestTypes e) {
  if (::flatbuffers::IsOutRange(e, StatusRequestTypes_All, StatusRequestTypes_LED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatusRequestTypes()[index];
}

enum Color : int8_t {
  Color_Red = 0,
  Color_Green = 1,
  Color_Blue = 2,
  Color_MIN = Color_Red,
  Color_MAX = Color_Blue
};

inline const Color (&EnumValuesColor())[3] {
  static const Color values[] = {
    Color_Red,
    Color_Green,
    Color_Blue
  };
  return values;
}

inline const char * const *EnumNamesColor() {
  static const char * const names[4] = {
    "Red",
    "Green",
    "Blue",
    nullptr
  };
  return names;
}

inline const char *EnumNameColor(Color e) {
  if (::flatbuffers::IsOutRange(e, Color_Red, Color_Blue)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesColor()[index];
}

enum Equipment : uint8_t {
  Equipment_NONE = 0,
  Equipment_Weapon = 1,
  Equipment_MIN = Equipment_NONE,
  Equipment_MAX = Equipment_Weapon
};

inline const Equipment (&EnumValuesEquipment())[2] {
  static const Equipment values[] = {
    Equipment_NONE,
    Equipment_Weapon
  };
  return values;
}

inline const char * const *EnumNamesEquipment() {
  static const char * const names[3] = {
    "NONE",
    "Weapon",
    nullptr
  };
  return names;
}

inline const char *EnumNameEquipment(Equipment e) {
  if (::flatbuffers::IsOutRange(e, Equipment_NONE, Equipment_Weapon)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEquipment()[index];
}

template<typename T> struct EquipmentTraits {
  static const Equipment enum_value = Equipment_NONE;
};

template<> struct EquipmentTraits<bpio::Weapon> {
  static const Equipment enum_value = Equipment_Weapon;
};

bool VerifyEquipment(::flatbuffers::Verifier &verifier, const void *obj, Equipment type);
bool VerifyEquipmentVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum RequestPacketContents : uint8_t {
  RequestPacketContents_NONE = 0,
  RequestPacketContents_Monster = 1,
  RequestPacketContents_StatusRequest = 2,
  RequestPacketContents_ConfigurationRequest = 3,
  RequestPacketContents_DataRequest = 4,
  RequestPacketContents_MIN = RequestPacketContents_NONE,
  RequestPacketContents_MAX = RequestPacketContents_DataRequest
};

inline const RequestPacketContents (&EnumValuesRequestPacketContents())[5] {
  static const RequestPacketContents values[] = {
    RequestPacketContents_NONE,
    RequestPacketContents_Monster,
    RequestPacketContents_StatusRequest,
    RequestPacketContents_ConfigurationRequest,
    RequestPacketContents_DataRequest
  };
  return values;
}

inline const char * const *EnumNamesRequestPacketContents() {
  static const char * const names[6] = {
    "NONE",
    "Monster",
    "StatusRequest",
    "ConfigurationRequest",
    "DataRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestPacketContents(RequestPacketContents e) {
  if (::flatbuffers::IsOutRange(e, RequestPacketContents_NONE, RequestPacketContents_DataRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestPacketContents()[index];
}

template<typename T> struct RequestPacketContentsTraits {
  static const RequestPacketContents enum_value = RequestPacketContents_NONE;
};

template<> struct RequestPacketContentsTraits<bpio::Monster> {
  static const RequestPacketContents enum_value = RequestPacketContents_Monster;
};

template<> struct RequestPacketContentsTraits<bpio::StatusRequest> {
  static const RequestPacketContents enum_value = RequestPacketContents_StatusRequest;
};

template<> struct RequestPacketContentsTraits<bpio::ConfigurationRequest> {
  static const RequestPacketContents enum_value = RequestPacketContents_ConfigurationRequest;
};

template<> struct RequestPacketContentsTraits<bpio::DataRequest> {
  static const RequestPacketContents enum_value = RequestPacketContents_DataRequest;
};

bool VerifyRequestPacketContents(::flatbuffers::Verifier &verifier, const void *obj, RequestPacketContents type);
bool VerifyRequestPacketContentsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum ResponsePacketContents : uint8_t {
  ResponsePacketContents_NONE = 0,
  ResponsePacketContents_ErrorResponse = 1,
  ResponsePacketContents_Monster = 2,
  ResponsePacketContents_ConfigurationResponse = 3,
  ResponsePacketContents_StatusResponse = 4,
  ResponsePacketContents_DataResponse = 5,
  ResponsePacketContents_MIN = ResponsePacketContents_NONE,
  ResponsePacketContents_MAX = ResponsePacketContents_DataResponse
};

inline const ResponsePacketContents (&EnumValuesResponsePacketContents())[6] {
  static const ResponsePacketContents values[] = {
    ResponsePacketContents_NONE,
    ResponsePacketContents_ErrorResponse,
    ResponsePacketContents_Monster,
    ResponsePacketContents_ConfigurationResponse,
    ResponsePacketContents_StatusResponse,
    ResponsePacketContents_DataResponse
  };
  return values;
}

inline const char * const *EnumNamesResponsePacketContents() {
  static const char * const names[7] = {
    "NONE",
    "ErrorResponse",
    "Monster",
    "ConfigurationResponse",
    "StatusResponse",
    "DataResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponsePacketContents(ResponsePacketContents e) {
  if (::flatbuffers::IsOutRange(e, ResponsePacketContents_NONE, ResponsePacketContents_DataResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResponsePacketContents()[index];
}

template<typename T> struct ResponsePacketContentsTraits {
  static const ResponsePacketContents enum_value = ResponsePacketContents_NONE;
};

template<> struct ResponsePacketContentsTraits<bpio::ErrorResponse> {
  static const ResponsePacketContents enum_value = ResponsePacketContents_ErrorResponse;
};

template<> struct ResponsePacketContentsTraits<bpio::Monster> {
  static const ResponsePacketContents enum_value = ResponsePacketContents_Monster;
};

template<> struct ResponsePacketContentsTraits<bpio::ConfigurationResponse> {
  static const ResponsePacketContents enum_value = ResponsePacketContents_ConfigurationResponse;
};

template<> struct ResponsePacketContentsTraits<bpio::StatusResponse> {
  static const ResponsePacketContents enum_value = ResponsePacketContents_StatusResponse;
};

template<> struct ResponsePacketContentsTraits<bpio::DataResponse> {
  static const ResponsePacketContents enum_value = ResponsePacketContents_DataResponse;
};

bool VerifyResponsePacketContents(::flatbuffers::Verifier &verifier, const void *obj, ResponsePacketContents type);
bool VerifyResponsePacketContentsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3(float _x, float _y, float _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

struct StatusRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatusRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_QUERY = 4
  };
  const ::flatbuffers::Vector<int8_t> *query() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_QUERY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_QUERY) &&
           verifier.VerifyVector(query()) &&
           verifier.EndTable();
  }
};

struct StatusRequestBuilder {
  typedef StatusRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_query(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> query) {
    fbb_.AddOffset(StatusRequest::VT_QUERY, query);
  }
  explicit StatusRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StatusRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StatusRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StatusRequest> CreateStatusRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> query = 0) {
  StatusRequestBuilder builder_(_fbb);
  builder_.add_query(query);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StatusRequest> CreateStatusRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *query = nullptr) {
  auto query__ = query ? _fbb.CreateVector<int8_t>(*query) : 0;
  return bpio::CreateStatusRequest(
      _fbb,
      query__);
}

struct Monster FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MonsterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_MANA = 6,
    VT_HP = 8,
    VT_NAME = 10,
    VT_INVENTORY = 14,
    VT_COLOR = 16,
    VT_WEAPONS = 18,
    VT_EQUIPPED_TYPE = 20,
    VT_EQUIPPED = 22,
    VT_PATH = 24
  };
  const bpio::Vec3 *pos() const {
    return GetStruct<const bpio::Vec3 *>(VT_POS);
  }
  int16_t mana() const {
    return GetField<int16_t>(VT_MANA, 150);
  }
  int16_t hp() const {
    return GetField<int16_t>(VT_HP, 100);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inventory() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INVENTORY);
  }
  bpio::Color color() const {
    return static_cast<bpio::Color>(GetField<int8_t>(VT_COLOR, 2));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<bpio::Weapon>> *weapons() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<bpio::Weapon>> *>(VT_WEAPONS);
  }
  bpio::Equipment equipped_type() const {
    return static_cast<bpio::Equipment>(GetField<uint8_t>(VT_EQUIPPED_TYPE, 0));
  }
  const void *equipped() const {
    return GetPointer<const void *>(VT_EQUIPPED);
  }
  template<typename T> const T *equipped_as() const;
  const bpio::Weapon *equipped_as_Weapon() const {
    return equipped_type() == bpio::Equipment_Weapon ? static_cast<const bpio::Weapon *>(equipped()) : nullptr;
  }
  const ::flatbuffers::Vector<const bpio::Vec3 *> *path() const {
    return GetPointer<const ::flatbuffers::Vector<const bpio::Vec3 *> *>(VT_PATH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<bpio::Vec3>(verifier, VT_POS, 4) &&
           VerifyField<int16_t>(verifier, VT_MANA, 2) &&
           VerifyField<int16_t>(verifier, VT_HP, 2) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INVENTORY) &&
           verifier.VerifyVector(inventory()) &&
           VerifyField<int8_t>(verifier, VT_COLOR, 1) &&
           VerifyOffset(verifier, VT_WEAPONS) &&
           verifier.VerifyVector(weapons()) &&
           verifier.VerifyVectorOfTables(weapons()) &&
           VerifyField<uint8_t>(verifier, VT_EQUIPPED_TYPE, 1) &&
           VerifyOffset(verifier, VT_EQUIPPED) &&
           VerifyEquipment(verifier, equipped(), equipped_type()) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyVector(path()) &&
           verifier.EndTable();
  }
};

template<> inline const bpio::Weapon *Monster::equipped_as<bpio::Weapon>() const {
  return equipped_as_Weapon();
}

struct MonsterBuilder {
  typedef Monster Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos(const bpio::Vec3 *pos) {
    fbb_.AddStruct(Monster::VT_POS, pos);
  }
  void add_mana(int16_t mana) {
    fbb_.AddElement<int16_t>(Monster::VT_MANA, mana, 150);
  }
  void add_hp(int16_t hp) {
    fbb_.AddElement<int16_t>(Monster::VT_HP, hp, 100);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Monster::VT_NAME, name);
  }
  void add_inventory(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inventory) {
    fbb_.AddOffset(Monster::VT_INVENTORY, inventory);
  }
  void add_color(bpio::Color color) {
    fbb_.AddElement<int8_t>(Monster::VT_COLOR, static_cast<int8_t>(color), 2);
  }
  void add_weapons(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<bpio::Weapon>>> weapons) {
    fbb_.AddOffset(Monster::VT_WEAPONS, weapons);
  }
  void add_equipped_type(bpio::Equipment equipped_type) {
    fbb_.AddElement<uint8_t>(Monster::VT_EQUIPPED_TYPE, static_cast<uint8_t>(equipped_type), 0);
  }
  void add_equipped(::flatbuffers::Offset<void> equipped) {
    fbb_.AddOffset(Monster::VT_EQUIPPED, equipped);
  }
  void add_path(::flatbuffers::Offset<::flatbuffers::Vector<const bpio::Vec3 *>> path) {
    fbb_.AddOffset(Monster::VT_PATH, path);
  }
  explicit MonsterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Monster> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Monster>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Monster> CreateMonster(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const bpio::Vec3 *pos = nullptr,
    int16_t mana = 150,
    int16_t hp = 100,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inventory = 0,
    bpio::Color color = bpio::Color_Blue,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<bpio::Weapon>>> weapons = 0,
    bpio::Equipment equipped_type = bpio::Equipment_NONE,
    ::flatbuffers::Offset<void> equipped = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const bpio::Vec3 *>> path = 0) {
  MonsterBuilder builder_(_fbb);
  builder_.add_path(path);
  builder_.add_equipped(equipped);
  builder_.add_weapons(weapons);
  builder_.add_inventory(inventory);
  builder_.add_name(name);
  builder_.add_pos(pos);
  builder_.add_hp(hp);
  builder_.add_mana(mana);
  builder_.add_equipped_type(equipped_type);
  builder_.add_color(color);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Monster> CreateMonsterDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const bpio::Vec3 *pos = nullptr,
    int16_t mana = 150,
    int16_t hp = 100,
    const char *name = nullptr,
    const std::vector<uint8_t> *inventory = nullptr,
    bpio::Color color = bpio::Color_Blue,
    const std::vector<::flatbuffers::Offset<bpio::Weapon>> *weapons = nullptr,
    bpio::Equipment equipped_type = bpio::Equipment_NONE,
    ::flatbuffers::Offset<void> equipped = 0,
    const std::vector<bpio::Vec3> *path = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inventory__ = inventory ? _fbb.CreateVector<uint8_t>(*inventory) : 0;
  auto weapons__ = weapons ? _fbb.CreateVector<::flatbuffers::Offset<bpio::Weapon>>(*weapons) : 0;
  auto path__ = path ? _fbb.CreateVectorOfStructs<bpio::Vec3>(*path) : 0;
  return bpio::CreateMonster(
      _fbb,
      pos,
      mana,
      hp,
      name__,
      inventory__,
      color,
      weapons__,
      equipped_type,
      equipped,
      path__);
}

struct Weapon FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WeaponBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DAMAGE = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int16_t damage() const {
    return GetField<int16_t>(VT_DAMAGE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_DAMAGE, 2) &&
           verifier.EndTable();
  }
};

struct WeaponBuilder {
  typedef Weapon Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Weapon::VT_NAME, name);
  }
  void add_damage(int16_t damage) {
    fbb_.AddElement<int16_t>(Weapon::VT_DAMAGE, damage, 0);
  }
  explicit WeaponBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Weapon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Weapon>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Weapon> CreateWeapon(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int16_t damage = 0) {
  WeaponBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_damage(damage);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Weapon> CreateWeaponDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int16_t damage = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return bpio::CreateWeapon(
      _fbb,
      name__,
      damage);
}

struct StatusResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatusResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR = 4,
    VT_PSU_ENABLED = 6,
    VT_PSU_SET_MV = 8,
    VT_PSU_SET_MA = 10,
    VT_PSU_MEASURED_MV = 12,
    VT_PSU_MEASURED_MA = 14,
    VT_PSU_CURRENT_ERROR = 16,
    VT_PULLUP_ENABLED = 18,
    VT_ADC_MV = 20,
    VT_IO_DIRECTION = 22,
    VT_IO_VALUE = 24,
    VT_DISK_SIZE_MB = 26,
    VT_DISK_USED_MB = 28,
    VT_LED_COUNT = 30,
    VT_VERSION_FLATBUFFERS_MAJOR = 32,
    VT_VERSION_FLATBUFFERS_MINOR = 34,
    VT_VERSION_HARDWARE_MAJOR = 36,
    VT_VERSION_HARDWARE_MINOR = 38,
    VT_VERSION_FIRMWARE_MAJOR = 40,
    VT_VERSION_FIRMWARE_MINOR = 42,
    VT_VERSION_FIRMWARE_GIT_HASH = 44,
    VT_VERSION_FIRMWARE_DATE = 46,
    VT_MODES_AVAILABLE = 48,
    VT_MODE_CURRENT = 50,
    VT_MODE_PIN_LABELS = 52,
    VT_MODE_BITORDER_MSB = 54,
    VT_MODE_MAX_PACKET_SIZE = 56,
    VT_MODE_MAX_WRITE = 58,
    VT_MODE_MAX_READ = 60
  };
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  bool psu_enabled() const {
    return GetField<uint8_t>(VT_PSU_ENABLED, 0) != 0;
  }
  uint32_t psu_set_mv() const {
    return GetField<uint32_t>(VT_PSU_SET_MV, 0);
  }
  uint32_t psu_set_ma() const {
    return GetField<uint32_t>(VT_PSU_SET_MA, 0);
  }
  uint32_t psu_measured_mv() const {
    return GetField<uint32_t>(VT_PSU_MEASURED_MV, 0);
  }
  uint32_t psu_measured_ma() const {
    return GetField<uint32_t>(VT_PSU_MEASURED_MA, 0);
  }
  bool psu_current_error() const {
    return GetField<uint8_t>(VT_PSU_CURRENT_ERROR, 0) != 0;
  }
  bool pullup_enabled() const {
    return GetField<uint8_t>(VT_PULLUP_ENABLED, 0) != 0;
  }
  const ::flatbuffers::Vector<uint32_t> *adc_mv() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_ADC_MV);
  }
  uint8_t io_direction() const {
    return GetField<uint8_t>(VT_IO_DIRECTION, 0);
  }
  uint8_t io_value() const {
    return GetField<uint8_t>(VT_IO_VALUE, 0);
  }
  float disk_size_mb() const {
    return GetField<float>(VT_DISK_SIZE_MB, 0.0f);
  }
  float disk_used_mb() const {
    return GetField<float>(VT_DISK_USED_MB, 0.0f);
  }
  uint8_t led_count() const {
    return GetField<uint8_t>(VT_LED_COUNT, 0);
  }
  uint8_t version_flatbuffers_major() const {
    return GetField<uint8_t>(VT_VERSION_FLATBUFFERS_MAJOR, 0);
  }
  uint16_t version_flatbuffers_minor() const {
    return GetField<uint16_t>(VT_VERSION_FLATBUFFERS_MINOR, 0);
  }
  uint8_t version_hardware_major() const {
    return GetField<uint8_t>(VT_VERSION_HARDWARE_MAJOR, 0);
  }
  uint8_t version_hardware_minor() const {
    return GetField<uint8_t>(VT_VERSION_HARDWARE_MINOR, 0);
  }
  uint8_t version_firmware_major() const {
    return GetField<uint8_t>(VT_VERSION_FIRMWARE_MAJOR, 0);
  }
  uint8_t version_firmware_minor() const {
    return GetField<uint8_t>(VT_VERSION_FIRMWARE_MINOR, 0);
  }
  const ::flatbuffers::String *version_firmware_git_hash() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION_FIRMWARE_GIT_HASH);
  }
  const ::flatbuffers::String *version_firmware_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION_FIRMWARE_DATE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *modes_available() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MODES_AVAILABLE);
  }
  const ::flatbuffers::String *mode_current() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MODE_CURRENT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mode_pin_labels() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MODE_PIN_LABELS);
  }
  bool mode_bitorder_msb() const {
    return GetField<uint8_t>(VT_MODE_BITORDER_MSB, 0) != 0;
  }
  uint32_t mode_max_packet_size() const {
    return GetField<uint32_t>(VT_MODE_MAX_PACKET_SIZE, 0);
  }
  uint32_t mode_max_write() const {
    return GetField<uint32_t>(VT_MODE_MAX_WRITE, 0);
  }
  uint32_t mode_max_read() const {
    return GetField<uint32_t>(VT_MODE_MAX_READ, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           VerifyField<uint8_t>(verifier, VT_PSU_ENABLED, 1) &&
           VerifyField<uint32_t>(verifier, VT_PSU_SET_MV, 4) &&
           VerifyField<uint32_t>(verifier, VT_PSU_SET_MA, 4) &&
           VerifyField<uint32_t>(verifier, VT_PSU_MEASURED_MV, 4) &&
           VerifyField<uint32_t>(verifier, VT_PSU_MEASURED_MA, 4) &&
           VerifyField<uint8_t>(verifier, VT_PSU_CURRENT_ERROR, 1) &&
           VerifyField<uint8_t>(verifier, VT_PULLUP_ENABLED, 1) &&
           VerifyOffset(verifier, VT_ADC_MV) &&
           verifier.VerifyVector(adc_mv()) &&
           VerifyField<uint8_t>(verifier, VT_IO_DIRECTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_IO_VALUE, 1) &&
           VerifyField<float>(verifier, VT_DISK_SIZE_MB, 4) &&
           VerifyField<float>(verifier, VT_DISK_USED_MB, 4) &&
           VerifyField<uint8_t>(verifier, VT_LED_COUNT, 1) &&
           VerifyField<uint8_t>(verifier, VT_VERSION_FLATBUFFERS_MAJOR, 1) &&
           VerifyField<uint16_t>(verifier, VT_VERSION_FLATBUFFERS_MINOR, 2) &&
           VerifyField<uint8_t>(verifier, VT_VERSION_HARDWARE_MAJOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_VERSION_HARDWARE_MINOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_VERSION_FIRMWARE_MAJOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_VERSION_FIRMWARE_MINOR, 1) &&
           VerifyOffset(verifier, VT_VERSION_FIRMWARE_GIT_HASH) &&
           verifier.VerifyString(version_firmware_git_hash()) &&
           VerifyOffset(verifier, VT_VERSION_FIRMWARE_DATE) &&
           verifier.VerifyString(version_firmware_date()) &&
           VerifyOffset(verifier, VT_MODES_AVAILABLE) &&
           verifier.VerifyVector(modes_available()) &&
           verifier.VerifyVectorOfStrings(modes_available()) &&
           VerifyOffset(verifier, VT_MODE_CURRENT) &&
           verifier.VerifyString(mode_current()) &&
           VerifyOffset(verifier, VT_MODE_PIN_LABELS) &&
           verifier.VerifyVector(mode_pin_labels()) &&
           verifier.VerifyVectorOfStrings(mode_pin_labels()) &&
           VerifyField<uint8_t>(verifier, VT_MODE_BITORDER_MSB, 1) &&
           VerifyField<uint32_t>(verifier, VT_MODE_MAX_PACKET_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_MODE_MAX_WRITE, 4) &&
           VerifyField<uint32_t>(verifier, VT_MODE_MAX_READ, 4) &&
           verifier.EndTable();
  }
};

struct StatusResponseBuilder {
  typedef StatusResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(StatusResponse::VT_ERROR, error);
  }
  void add_psu_enabled(bool psu_enabled) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_PSU_ENABLED, static_cast<uint8_t>(psu_enabled), 0);
  }
  void add_psu_set_mv(uint32_t psu_set_mv) {
    fbb_.AddElement<uint32_t>(StatusResponse::VT_PSU_SET_MV, psu_set_mv, 0);
  }
  void add_psu_set_ma(uint32_t psu_set_ma) {
    fbb_.AddElement<uint32_t>(StatusResponse::VT_PSU_SET_MA, psu_set_ma, 0);
  }
  void add_psu_measured_mv(uint32_t psu_measured_mv) {
    fbb_.AddElement<uint32_t>(StatusResponse::VT_PSU_MEASURED_MV, psu_measured_mv, 0);
  }
  void add_psu_measured_ma(uint32_t psu_measured_ma) {
    fbb_.AddElement<uint32_t>(StatusResponse::VT_PSU_MEASURED_MA, psu_measured_ma, 0);
  }
  void add_psu_current_error(bool psu_current_error) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_PSU_CURRENT_ERROR, static_cast<uint8_t>(psu_current_error), 0);
  }
  void add_pullup_enabled(bool pullup_enabled) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_PULLUP_ENABLED, static_cast<uint8_t>(pullup_enabled), 0);
  }
  void add_adc_mv(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> adc_mv) {
    fbb_.AddOffset(StatusResponse::VT_ADC_MV, adc_mv);
  }
  void add_io_direction(uint8_t io_direction) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_IO_DIRECTION, io_direction, 0);
  }
  void add_io_value(uint8_t io_value) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_IO_VALUE, io_value, 0);
  }
  void add_disk_size_mb(float disk_size_mb) {
    fbb_.AddElement<float>(StatusResponse::VT_DISK_SIZE_MB, disk_size_mb, 0.0f);
  }
  void add_disk_used_mb(float disk_used_mb) {
    fbb_.AddElement<float>(StatusResponse::VT_DISK_USED_MB, disk_used_mb, 0.0f);
  }
  void add_led_count(uint8_t led_count) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_LED_COUNT, led_count, 0);
  }
  void add_version_flatbuffers_major(uint8_t version_flatbuffers_major) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_VERSION_FLATBUFFERS_MAJOR, version_flatbuffers_major, 0);
  }
  void add_version_flatbuffers_minor(uint16_t version_flatbuffers_minor) {
    fbb_.AddElement<uint16_t>(StatusResponse::VT_VERSION_FLATBUFFERS_MINOR, version_flatbuffers_minor, 0);
  }
  void add_version_hardware_major(uint8_t version_hardware_major) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_VERSION_HARDWARE_MAJOR, version_hardware_major, 0);
  }
  void add_version_hardware_minor(uint8_t version_hardware_minor) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_VERSION_HARDWARE_MINOR, version_hardware_minor, 0);
  }
  void add_version_firmware_major(uint8_t version_firmware_major) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_VERSION_FIRMWARE_MAJOR, version_firmware_major, 0);
  }
  void add_version_firmware_minor(uint8_t version_firmware_minor) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_VERSION_FIRMWARE_MINOR, version_firmware_minor, 0);
  }
  void add_version_firmware_git_hash(::flatbuffers::Offset<::flatbuffers::String> version_firmware_git_hash) {
    fbb_.AddOffset(StatusResponse::VT_VERSION_FIRMWARE_GIT_HASH, version_firmware_git_hash);
  }
  void add_version_firmware_date(::flatbuffers::Offset<::flatbuffers::String> version_firmware_date) {
    fbb_.AddOffset(StatusResponse::VT_VERSION_FIRMWARE_DATE, version_firmware_date);
  }
  void add_modes_available(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> modes_available) {
    fbb_.AddOffset(StatusResponse::VT_MODES_AVAILABLE, modes_available);
  }
  void add_mode_current(::flatbuffers::Offset<::flatbuffers::String> mode_current) {
    fbb_.AddOffset(StatusResponse::VT_MODE_CURRENT, mode_current);
  }
  void add_mode_pin_labels(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> mode_pin_labels) {
    fbb_.AddOffset(StatusResponse::VT_MODE_PIN_LABELS, mode_pin_labels);
  }
  void add_mode_bitorder_msb(bool mode_bitorder_msb) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_MODE_BITORDER_MSB, static_cast<uint8_t>(mode_bitorder_msb), 0);
  }
  void add_mode_max_packet_size(uint32_t mode_max_packet_size) {
    fbb_.AddElement<uint32_t>(StatusResponse::VT_MODE_MAX_PACKET_SIZE, mode_max_packet_size, 0);
  }
  void add_mode_max_write(uint32_t mode_max_write) {
    fbb_.AddElement<uint32_t>(StatusResponse::VT_MODE_MAX_WRITE, mode_max_write, 0);
  }
  void add_mode_max_read(uint32_t mode_max_read) {
    fbb_.AddElement<uint32_t>(StatusResponse::VT_MODE_MAX_READ, mode_max_read, 0);
  }
  explicit StatusResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StatusResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StatusResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StatusResponse> CreateStatusResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0,
    bool psu_enabled = false,
    uint32_t psu_set_mv = 0,
    uint32_t psu_set_ma = 0,
    uint32_t psu_measured_mv = 0,
    uint32_t psu_measured_ma = 0,
    bool psu_current_error = false,
    bool pullup_enabled = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> adc_mv = 0,
    uint8_t io_direction = 0,
    uint8_t io_value = 0,
    float disk_size_mb = 0.0f,
    float disk_used_mb = 0.0f,
    uint8_t led_count = 0,
    uint8_t version_flatbuffers_major = 0,
    uint16_t version_flatbuffers_minor = 0,
    uint8_t version_hardware_major = 0,
    uint8_t version_hardware_minor = 0,
    uint8_t version_firmware_major = 0,
    uint8_t version_firmware_minor = 0,
    ::flatbuffers::Offset<::flatbuffers::String> version_firmware_git_hash = 0,
    ::flatbuffers::Offset<::flatbuffers::String> version_firmware_date = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> modes_available = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mode_current = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> mode_pin_labels = 0,
    bool mode_bitorder_msb = false,
    uint32_t mode_max_packet_size = 0,
    uint32_t mode_max_write = 0,
    uint32_t mode_max_read = 0) {
  StatusResponseBuilder builder_(_fbb);
  builder_.add_mode_max_read(mode_max_read);
  builder_.add_mode_max_write(mode_max_write);
  builder_.add_mode_max_packet_size(mode_max_packet_size);
  builder_.add_mode_pin_labels(mode_pin_labels);
  builder_.add_mode_current(mode_current);
  builder_.add_modes_available(modes_available);
  builder_.add_version_firmware_date(version_firmware_date);
  builder_.add_version_firmware_git_hash(version_firmware_git_hash);
  builder_.add_disk_used_mb(disk_used_mb);
  builder_.add_disk_size_mb(disk_size_mb);
  builder_.add_adc_mv(adc_mv);
  builder_.add_psu_measured_ma(psu_measured_ma);
  builder_.add_psu_measured_mv(psu_measured_mv);
  builder_.add_psu_set_ma(psu_set_ma);
  builder_.add_psu_set_mv(psu_set_mv);
  builder_.add_error(error);
  builder_.add_version_flatbuffers_minor(version_flatbuffers_minor);
  builder_.add_mode_bitorder_msb(mode_bitorder_msb);
  builder_.add_version_firmware_minor(version_firmware_minor);
  builder_.add_version_firmware_major(version_firmware_major);
  builder_.add_version_hardware_minor(version_hardware_minor);
  builder_.add_version_hardware_major(version_hardware_major);
  builder_.add_version_flatbuffers_major(version_flatbuffers_major);
  builder_.add_led_count(led_count);
  builder_.add_io_value(io_value);
  builder_.add_io_direction(io_direction);
  builder_.add_pullup_enabled(pullup_enabled);
  builder_.add_psu_current_error(psu_current_error);
  builder_.add_psu_enabled(psu_enabled);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StatusResponse> CreateStatusResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *error = nullptr,
    bool psu_enabled = false,
    uint32_t psu_set_mv = 0,
    uint32_t psu_set_ma = 0,
    uint32_t psu_measured_mv = 0,
    uint32_t psu_measured_ma = 0,
    bool psu_current_error = false,
    bool pullup_enabled = false,
    const std::vector<uint32_t> *adc_mv = nullptr,
    uint8_t io_direction = 0,
    uint8_t io_value = 0,
    float disk_size_mb = 0.0f,
    float disk_used_mb = 0.0f,
    uint8_t led_count = 0,
    uint8_t version_flatbuffers_major = 0,
    uint16_t version_flatbuffers_minor = 0,
    uint8_t version_hardware_major = 0,
    uint8_t version_hardware_minor = 0,
    uint8_t version_firmware_major = 0,
    uint8_t version_firmware_minor = 0,
    const char *version_firmware_git_hash = nullptr,
    const char *version_firmware_date = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *modes_available = nullptr,
    const char *mode_current = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *mode_pin_labels = nullptr,
    bool mode_bitorder_msb = false,
    uint32_t mode_max_packet_size = 0,
    uint32_t mode_max_write = 0,
    uint32_t mode_max_read = 0) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  auto adc_mv__ = adc_mv ? _fbb.CreateVector<uint32_t>(*adc_mv) : 0;
  auto version_firmware_git_hash__ = version_firmware_git_hash ? _fbb.CreateString(version_firmware_git_hash) : 0;
  auto version_firmware_date__ = version_firmware_date ? _fbb.CreateString(version_firmware_date) : 0;
  auto modes_available__ = modes_available ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*modes_available) : 0;
  auto mode_current__ = mode_current ? _fbb.CreateString(mode_current) : 0;
  auto mode_pin_labels__ = mode_pin_labels ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*mode_pin_labels) : 0;
  return bpio::CreateStatusResponse(
      _fbb,
      error__,
      psu_enabled,
      psu_set_mv,
      psu_set_ma,
      psu_measured_mv,
      psu_measured_ma,
      psu_current_error,
      pullup_enabled,
      adc_mv__,
      io_direction,
      io_value,
      disk_size_mb,
      disk_used_mb,
      led_count,
      version_flatbuffers_major,
      version_flatbuffers_minor,
      version_hardware_major,
      version_hardware_minor,
      version_firmware_major,
      version_firmware_minor,
      version_firmware_git_hash__,
      version_firmware_date__,
      modes_available__,
      mode_current__,
      mode_pin_labels__,
      mode_bitorder_msb,
      mode_max_packet_size,
      mode_max_write,
      mode_max_read);
}

struct ModeConfiguration FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModeConfigurationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPEED = 4,
    VT_DATA_BITS = 6,
    VT_PARITY = 8,
    VT_STOP_BITS = 10,
    VT_FLOW_CONTROL = 12,
    VT_SIGNAL_INVERSION = 14,
    VT_SUBMODE = 16,
    VT_TX_MODULATION = 18,
    VT_RX_SENSOR = 20
  };
  uint32_t speed() const {
    return GetField<uint32_t>(VT_SPEED, 20000);
  }
  uint8_t data_bits() const {
    return GetField<uint8_t>(VT_DATA_BITS, 8);
  }
  bool parity() const {
    return GetField<uint8_t>(VT_PARITY, 0) != 0;
  }
  uint8_t stop_bits() const {
    return GetField<uint8_t>(VT_STOP_BITS, 1);
  }
  bool flow_control() const {
    return GetField<uint8_t>(VT_FLOW_CONTROL, 0) != 0;
  }
  bool signal_inversion() const {
    return GetField<uint8_t>(VT_SIGNAL_INVERSION, 0) != 0;
  }
  uint8_t submode() const {
    return GetField<uint8_t>(VT_SUBMODE, 0);
  }
  uint32_t tx_modulation() const {
    return GetField<uint32_t>(VT_TX_MODULATION, 0);
  }
  uint8_t rx_sensor() const {
    return GetField<uint8_t>(VT_RX_SENSOR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SPEED, 4) &&
           VerifyField<uint8_t>(verifier, VT_DATA_BITS, 1) &&
           VerifyField<uint8_t>(verifier, VT_PARITY, 1) &&
           VerifyField<uint8_t>(verifier, VT_STOP_BITS, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLOW_CONTROL, 1) &&
           VerifyField<uint8_t>(verifier, VT_SIGNAL_INVERSION, 1) &&
           VerifyField<uint8_t>(verifier, VT_SUBMODE, 1) &&
           VerifyField<uint32_t>(verifier, VT_TX_MODULATION, 4) &&
           VerifyField<uint8_t>(verifier, VT_RX_SENSOR, 1) &&
           verifier.EndTable();
  }
};

struct ModeConfigurationBuilder {
  typedef ModeConfiguration Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_speed(uint32_t speed) {
    fbb_.AddElement<uint32_t>(ModeConfiguration::VT_SPEED, speed, 20000);
  }
  void add_data_bits(uint8_t data_bits) {
    fbb_.AddElement<uint8_t>(ModeConfiguration::VT_DATA_BITS, data_bits, 8);
  }
  void add_parity(bool parity) {
    fbb_.AddElement<uint8_t>(ModeConfiguration::VT_PARITY, static_cast<uint8_t>(parity), 0);
  }
  void add_stop_bits(uint8_t stop_bits) {
    fbb_.AddElement<uint8_t>(ModeConfiguration::VT_STOP_BITS, stop_bits, 1);
  }
  void add_flow_control(bool flow_control) {
    fbb_.AddElement<uint8_t>(ModeConfiguration::VT_FLOW_CONTROL, static_cast<uint8_t>(flow_control), 0);
  }
  void add_signal_inversion(bool signal_inversion) {
    fbb_.AddElement<uint8_t>(ModeConfiguration::VT_SIGNAL_INVERSION, static_cast<uint8_t>(signal_inversion), 0);
  }
  void add_submode(uint8_t submode) {
    fbb_.AddElement<uint8_t>(ModeConfiguration::VT_SUBMODE, submode, 0);
  }
  void add_tx_modulation(uint32_t tx_modulation) {
    fbb_.AddElement<uint32_t>(ModeConfiguration::VT_TX_MODULATION, tx_modulation, 0);
  }
  void add_rx_sensor(uint8_t rx_sensor) {
    fbb_.AddElement<uint8_t>(ModeConfiguration::VT_RX_SENSOR, rx_sensor, 0);
  }
  explicit ModeConfigurationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ModeConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ModeConfiguration>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ModeConfiguration> CreateModeConfiguration(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t speed = 20000,
    uint8_t data_bits = 8,
    bool parity = false,
    uint8_t stop_bits = 1,
    bool flow_control = false,
    bool signal_inversion = false,
    uint8_t submode = 0,
    uint32_t tx_modulation = 0,
    uint8_t rx_sensor = 0) {
  ModeConfigurationBuilder builder_(_fbb);
  builder_.add_tx_modulation(tx_modulation);
  builder_.add_speed(speed);
  builder_.add_rx_sensor(rx_sensor);
  builder_.add_submode(submode);
  builder_.add_signal_inversion(signal_inversion);
  builder_.add_flow_control(flow_control);
  builder_.add_stop_bits(stop_bits);
  builder_.add_parity(parity);
  builder_.add_data_bits(data_bits);
  return builder_.Finish();
}

struct ConfigurationRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConfigurationRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_MODE_CONFIGURATION = 6,
    VT_MODE_BITORDER_MSB = 8,
    VT_MODE_BITORDER_LSB = 10,
    VT_PSU_DISABLE = 12,
    VT_PSU_ENABLE = 14,
    VT_PSU_SET_MV = 16,
    VT_PSU_SET_MA = 18,
    VT_PULLUP_DISABLE = 20,
    VT_PULLUP_ENABLE = 22,
    VT_IO_DIRECTION_MASK = 24,
    VT_IO_DIRECTION = 26,
    VT_IO_VALUE_MASK = 28,
    VT_IO_VALUE = 30
  };
  const ::flatbuffers::String *mode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MODE);
  }
  const bpio::ModeConfiguration *mode_configuration() const {
    return GetPointer<const bpio::ModeConfiguration *>(VT_MODE_CONFIGURATION);
  }
  bool mode_bitorder_msb() const {
    return GetField<uint8_t>(VT_MODE_BITORDER_MSB, 0) != 0;
  }
  bool mode_bitorder_lsb() const {
    return GetField<uint8_t>(VT_MODE_BITORDER_LSB, 0) != 0;
  }
  bool psu_disable() const {
    return GetField<uint8_t>(VT_PSU_DISABLE, 0) != 0;
  }
  bool psu_enable() const {
    return GetField<uint8_t>(VT_PSU_ENABLE, 0) != 0;
  }
  uint32_t psu_set_mv() const {
    return GetField<uint32_t>(VT_PSU_SET_MV, 0);
  }
  uint16_t psu_set_ma() const {
    return GetField<uint16_t>(VT_PSU_SET_MA, 300);
  }
  bool pullup_disable() const {
    return GetField<uint8_t>(VT_PULLUP_DISABLE, 0) != 0;
  }
  bool pullup_enable() const {
    return GetField<uint8_t>(VT_PULLUP_ENABLE, 0) != 0;
  }
  uint8_t io_direction_mask() const {
    return GetField<uint8_t>(VT_IO_DIRECTION_MASK, 0);
  }
  uint8_t io_direction() const {
    return GetField<uint8_t>(VT_IO_DIRECTION, 0);
  }
  uint8_t io_value_mask() const {
    return GetField<uint8_t>(VT_IO_VALUE_MASK, 0);
  }
  uint8_t io_value() const {
    return GetField<uint8_t>(VT_IO_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODE) &&
           verifier.VerifyString(mode()) &&
           VerifyOffset(verifier, VT_MODE_CONFIGURATION) &&
           verifier.VerifyTable(mode_configuration()) &&
           VerifyField<uint8_t>(verifier, VT_MODE_BITORDER_MSB, 1) &&
           VerifyField<uint8_t>(verifier, VT_MODE_BITORDER_LSB, 1) &&
           VerifyField<uint8_t>(verifier, VT_PSU_DISABLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_PSU_ENABLE, 1) &&
           VerifyField<uint32_t>(verifier, VT_PSU_SET_MV, 4) &&
           VerifyField<uint16_t>(verifier, VT_PSU_SET_MA, 2) &&
           VerifyField<uint8_t>(verifier, VT_PULLUP_DISABLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_PULLUP_ENABLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_IO_DIRECTION_MASK, 1) &&
           VerifyField<uint8_t>(verifier, VT_IO_DIRECTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_IO_VALUE_MASK, 1) &&
           VerifyField<uint8_t>(verifier, VT_IO_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct ConfigurationRequestBuilder {
  typedef ConfigurationRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mode(::flatbuffers::Offset<::flatbuffers::String> mode) {
    fbb_.AddOffset(ConfigurationRequest::VT_MODE, mode);
  }
  void add_mode_configuration(::flatbuffers::Offset<bpio::ModeConfiguration> mode_configuration) {
    fbb_.AddOffset(ConfigurationRequest::VT_MODE_CONFIGURATION, mode_configuration);
  }
  void add_mode_bitorder_msb(bool mode_bitorder_msb) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_MODE_BITORDER_MSB, static_cast<uint8_t>(mode_bitorder_msb), 0);
  }
  void add_mode_bitorder_lsb(bool mode_bitorder_lsb) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_MODE_BITORDER_LSB, static_cast<uint8_t>(mode_bitorder_lsb), 0);
  }
  void add_psu_disable(bool psu_disable) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_PSU_DISABLE, static_cast<uint8_t>(psu_disable), 0);
  }
  void add_psu_enable(bool psu_enable) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_PSU_ENABLE, static_cast<uint8_t>(psu_enable), 0);
  }
  void add_psu_set_mv(uint32_t psu_set_mv) {
    fbb_.AddElement<uint32_t>(ConfigurationRequest::VT_PSU_SET_MV, psu_set_mv, 0);
  }
  void add_psu_set_ma(uint16_t psu_set_ma) {
    fbb_.AddElement<uint16_t>(ConfigurationRequest::VT_PSU_SET_MA, psu_set_ma, 300);
  }
  void add_pullup_disable(bool pullup_disable) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_PULLUP_DISABLE, static_cast<uint8_t>(pullup_disable), 0);
  }
  void add_pullup_enable(bool pullup_enable) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_PULLUP_ENABLE, static_cast<uint8_t>(pullup_enable), 0);
  }
  void add_io_direction_mask(uint8_t io_direction_mask) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_IO_DIRECTION_MASK, io_direction_mask, 0);
  }
  void add_io_direction(uint8_t io_direction) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_IO_DIRECTION, io_direction, 0);
  }
  void add_io_value_mask(uint8_t io_value_mask) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_IO_VALUE_MASK, io_value_mask, 0);
  }
  void add_io_value(uint8_t io_value) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_IO_VALUE, io_value, 0);
  }
  explicit ConfigurationRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConfigurationRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConfigurationRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConfigurationRequest> CreateConfigurationRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> mode = 0,
    ::flatbuffers::Offset<bpio::ModeConfiguration> mode_configuration = 0,
    bool mode_bitorder_msb = false,
    bool mode_bitorder_lsb = false,
    bool psu_disable = false,
    bool psu_enable = false,
    uint32_t psu_set_mv = 0,
    uint16_t psu_set_ma = 300,
    bool pullup_disable = false,
    bool pullup_enable = false,
    uint8_t io_direction_mask = 0,
    uint8_t io_direction = 0,
    uint8_t io_value_mask = 0,
    uint8_t io_value = 0) {
  ConfigurationRequestBuilder builder_(_fbb);
  builder_.add_psu_set_mv(psu_set_mv);
  builder_.add_mode_configuration(mode_configuration);
  builder_.add_mode(mode);
  builder_.add_psu_set_ma(psu_set_ma);
  builder_.add_io_value(io_value);
  builder_.add_io_value_mask(io_value_mask);
  builder_.add_io_direction(io_direction);
  builder_.add_io_direction_mask(io_direction_mask);
  builder_.add_pullup_enable(pullup_enable);
  builder_.add_pullup_disable(pullup_disable);
  builder_.add_psu_enable(psu_enable);
  builder_.add_psu_disable(psu_disable);
  builder_.add_mode_bitorder_lsb(mode_bitorder_lsb);
  builder_.add_mode_bitorder_msb(mode_bitorder_msb);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConfigurationRequest> CreateConfigurationRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *mode = nullptr,
    ::flatbuffers::Offset<bpio::ModeConfiguration> mode_configuration = 0,
    bool mode_bitorder_msb = false,
    bool mode_bitorder_lsb = false,
    bool psu_disable = false,
    bool psu_enable = false,
    uint32_t psu_set_mv = 0,
    uint16_t psu_set_ma = 300,
    bool pullup_disable = false,
    bool pullup_enable = false,
    uint8_t io_direction_mask = 0,
    uint8_t io_direction = 0,
    uint8_t io_value_mask = 0,
    uint8_t io_value = 0) {
  auto mode__ = mode ? _fbb.CreateString(mode) : 0;
  return bpio::CreateConfigurationRequest(
      _fbb,
      mode__,
      mode_configuration,
      mode_bitorder_msb,
      mode_bitorder_lsb,
      psu_disable,
      psu_enable,
      psu_set_mv,
      psu_set_ma,
      pullup_disable,
      pullup_enable,
      io_direction_mask,
      io_direction,
      io_value_mask,
      io_value);
}

struct ConfigurationResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConfigurationResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR = 4
  };
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
};

struct ConfigurationResponseBuilder {
  typedef ConfigurationResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(ConfigurationResponse::VT_ERROR, error);
  }
  explicit ConfigurationResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConfigurationResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConfigurationResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConfigurationResponse> CreateConfigurationResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0) {
  ConfigurationResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConfigurationResponse> CreateConfigurationResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *error = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return bpio::CreateConfigurationResponse(
      _fbb,
      error__);
}

struct DataRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DataRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_MAIN = 4,
    VT_START_ALT = 6,
    VT_DATA_WRITE = 8
  };
  bool start_main() const {
    return GetField<uint8_t>(VT_START_MAIN, 0) != 0;
  }
  bool start_alt() const {
    return GetField<uint8_t>(VT_START_ALT, 0) != 0;
  }
  const ::flatbuffers::Vector<uint8_t> *data_write() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA_WRITE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_START_MAIN, 1) &&
           VerifyField<uint8_t>(verifier, VT_START_ALT, 1) &&
           VerifyOffset(verifier, VT_DATA_WRITE) &&
           verifier.VerifyVector(data_write()) &&
           verifier.EndTable();
  }
};

struct DataRequestBuilder {
  typedef DataRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_start_main(bool start_main) {
    fbb_.AddElement<uint8_t>(DataRequest::VT_START_MAIN, static_cast<uint8_t>(start_main), 0);
  }
  void add_start_alt(bool start_alt) {
    fbb_.AddElement<uint8_t>(DataRequest::VT_START_ALT, static_cast<uint8_t>(start_alt), 0);
  }
  void add_data_write(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data_write) {
    fbb_.AddOffset(DataRequest::VT_DATA_WRITE, data_write);
  }
  explicit DataRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DataRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DataRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DataRequest> CreateDataRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool start_main = false,
    bool start_alt = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data_write = 0) {
  DataRequestBuilder builder_(_fbb);
  builder_.add_data_write(data_write);
  builder_.add_start_alt(start_alt);
  builder_.add_start_main(start_main);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DataRequest> CreateDataRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool start_main = false,
    bool start_alt = false,
    const std::vector<uint8_t> *data_write = nullptr) {
  auto data_write__ = data_write ? _fbb.CreateVector<uint8_t>(*data_write) : 0;
  return bpio::CreateDataRequest(
      _fbb,
      start_main,
      start_alt,
      data_write__);
}

struct DataResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DataResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR = 4,
    VT_DATA_READ = 6
  };
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  const ::flatbuffers::Vector<uint8_t> *data_read() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA_READ);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           VerifyOffset(verifier, VT_DATA_READ) &&
           verifier.VerifyVector(data_read()) &&
           verifier.EndTable();
  }
};

struct DataResponseBuilder {
  typedef DataResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(DataResponse::VT_ERROR, error);
  }
  void add_data_read(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data_read) {
    fbb_.AddOffset(DataResponse::VT_DATA_READ, data_read);
  }
  explicit DataResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DataResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DataResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DataResponse> CreateDataResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data_read = 0) {
  DataResponseBuilder builder_(_fbb);
  builder_.add_data_read(data_read);
  builder_.add_error(error);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DataResponse> CreateDataResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *error = nullptr,
    const std::vector<uint8_t> *data_read = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  auto data_read__ = data_read ? _fbb.CreateVector<uint8_t>(*data_read) : 0;
  return bpio::CreateDataResponse(
      _fbb,
      error__,
      data_read__);
}

struct ErrorResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrorResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR = 4
  };
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
};

struct ErrorResponseBuilder {
  typedef ErrorResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(ErrorResponse::VT_ERROR, error);
  }
  explicit ErrorResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ErrorResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ErrorResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ErrorResponse> CreateErrorResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0) {
  ErrorResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ErrorResponse> CreateErrorResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *error = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return bpio::CreateErrorResponse(
      _fbb,
      error__);
}

struct RequestPacket FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestPacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION_MAJOR = 4,
    VT_MINIMUM_VERSION_MINOR = 6,
    VT_CONTENTS_TYPE = 8,
    VT_CONTENTS = 10
  };
  uint8_t version_major() const {
    return GetField<uint8_t>(VT_VERSION_MAJOR, 0);
  }
  uint16_t minimum_version_minor() const {
    return GetField<uint16_t>(VT_MINIMUM_VERSION_MINOR, 0);
  }
  bpio::RequestPacketContents contents_type() const {
    return static_cast<bpio::RequestPacketContents>(GetField<uint8_t>(VT_CONTENTS_TYPE, 0));
  }
  const void *contents() const {
    return GetPointer<const void *>(VT_CONTENTS);
  }
  template<typename T> const T *contents_as() const;
  const bpio::Monster *contents_as_Monster() const {
    return contents_type() == bpio::RequestPacketContents_Monster ? static_cast<const bpio::Monster *>(contents()) : nullptr;
  }
  const bpio::StatusRequest *contents_as_StatusRequest() const {
    return contents_type() == bpio::RequestPacketContents_StatusRequest ? static_cast<const bpio::StatusRequest *>(contents()) : nullptr;
  }
  const bpio::ConfigurationRequest *contents_as_ConfigurationRequest() const {
    return contents_type() == bpio::RequestPacketContents_ConfigurationRequest ? static_cast<const bpio::ConfigurationRequest *>(contents()) : nullptr;
  }
  const bpio::DataRequest *contents_as_DataRequest() const {
    return contents_type() == bpio::RequestPacketContents_DataRequest ? static_cast<const bpio::DataRequest *>(contents()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VERSION_MAJOR, 1) &&
           VerifyField<uint16_t>(verifier, VT_MINIMUM_VERSION_MINOR, 2) &&
           VerifyField<uint8_t>(verifier, VT_CONTENTS_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONTENTS) &&
           VerifyRequestPacketContents(verifier, contents(), contents_type()) &&
           verifier.EndTable();
  }
};

template<> inline const bpio::Monster *RequestPacket::contents_as<bpio::Monster>() const {
  return contents_as_Monster();
}

template<> inline const bpio::StatusRequest *RequestPacket::contents_as<bpio::StatusRequest>() const {
  return contents_as_StatusRequest();
}

template<> inline const bpio::ConfigurationRequest *RequestPacket::contents_as<bpio::ConfigurationRequest>() const {
  return contents_as_ConfigurationRequest();
}

template<> inline const bpio::DataRequest *RequestPacket::contents_as<bpio::DataRequest>() const {
  return contents_as_DataRequest();
}

struct RequestPacketBuilder {
  typedef RequestPacket Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version_major(uint8_t version_major) {
    fbb_.AddElement<uint8_t>(RequestPacket::VT_VERSION_MAJOR, version_major, 0);
  }
  void add_minimum_version_minor(uint16_t minimum_version_minor) {
    fbb_.AddElement<uint16_t>(RequestPacket::VT_MINIMUM_VERSION_MINOR, minimum_version_minor, 0);
  }
  void add_contents_type(bpio::RequestPacketContents contents_type) {
    fbb_.AddElement<uint8_t>(RequestPacket::VT_CONTENTS_TYPE, static_cast<uint8_t>(contents_type), 0);
  }
  void add_contents(::flatbuffers::Offset<void> contents) {
    fbb_.AddOffset(RequestPacket::VT_CONTENTS, contents);
  }
  explicit RequestPacketBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestPacket>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestPacket> CreateRequestPacket(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t version_major = 0,
    uint16_t minimum_version_minor = 0,
    bpio::RequestPacketContents contents_type = bpio::RequestPacketContents_NONE,
    ::flatbuffers::Offset<void> contents = 0) {
  RequestPacketBuilder builder_(_fbb);
  builder_.add_contents(contents);
  builder_.add_minimum_version_minor(minimum_version_minor);
  builder_.add_contents_type(contents_type);
  builder_.add_version_major(version_major);
  return builder_.Finish();
}

struct ResponsePacket FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponsePacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR = 4,
    VT_CONTENTS_TYPE = 6,
    VT_CONTENTS = 8
  };
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  bpio::ResponsePacketContents contents_type() const {
    return static_cast<bpio::ResponsePacketContents>(GetField<uint8_t>(VT_CONTENTS_TYPE, 0));
  }
  const void *contents() const {
    return GetPointer<const void *>(VT_CONTENTS);
  }
  template<typename T> const T *contents_as() const;
  const bpio::ErrorResponse *contents_as_ErrorResponse() const {
    return contents_type() == bpio::ResponsePacketContents_ErrorResponse ? static_cast<const bpio::ErrorResponse *>(contents()) : nullptr;
  }
  const bpio::Monster *contents_as_Monster() const {
    return contents_type() == bpio::ResponsePacketContents_Monster ? static_cast<const bpio::Monster *>(contents()) : nullptr;
  }
  const bpio::ConfigurationResponse *contents_as_ConfigurationResponse() const {
    return contents_type() == bpio::ResponsePacketContents_ConfigurationResponse ? static_cast<const bpio::ConfigurationResponse *>(contents()) : nullptr;
  }
  const bpio::StatusResponse *contents_as_StatusResponse() const {
    return contents_type() == bpio::ResponsePacketContents_StatusResponse ? static_cast<const bpio::StatusResponse *>(contents()) : nullptr;
  }
  const bpio::DataResponse *contents_as_DataResponse() const {
    return contents_type() == bpio::ResponsePacketContents_DataResponse ? static_cast<const bpio::DataResponse *>(contents()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           VerifyField<uint8_t>(verifier, VT_CONTENTS_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONTENTS) &&
           VerifyResponsePacketContents(verifier, contents(), contents_type()) &&
           verifier.EndTable();
  }
};

template<> inline const bpio::ErrorResponse *ResponsePacket::contents_as<bpio::ErrorResponse>() const {
  return contents_as_ErrorResponse();
}

template<> inline const bpio::Monster *ResponsePacket::contents_as<bpio::Monster>() const {
  return contents_as_Monster();
}

template<> inline const bpio::ConfigurationResponse *ResponsePacket::contents_as<bpio::ConfigurationResponse>() const {
  return contents_as_ConfigurationResponse();
}

template<> inline const bpio::StatusResponse *ResponsePacket::contents_as<bpio::StatusResponse>() const {
  return contents_as_StatusResponse();
}

template<> inline const bpio::DataResponse *ResponsePacket::contents_as<bpio::DataResponse>() const {
  return contents_as_DataResponse();
}

struct ResponsePacketBuilder {
  typedef ResponsePacket Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(ResponsePacket::VT_ERROR, error);
  }
  void add_contents_type(bpio::ResponsePacketContents contents_type) {
    fbb_.AddElement<uint8_t>(ResponsePacket::VT_CONTENTS_TYPE, static_cast<uint8_t>(contents_type), 0);
  }
  void add_contents(::flatbuffers::Offset<void> contents) {
    fbb_.AddOffset(ResponsePacket::VT_CONTENTS, contents);
  }
  explicit ResponsePacketBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponsePacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponsePacket>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponsePacket> CreateResponsePacket(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0,
    bpio::ResponsePacketContents contents_type = bpio::ResponsePacketContents_NONE,
    ::flatbuffers::Offset<void> contents = 0) {
  ResponsePacketBuilder builder_(_fbb);
  builder_.add_contents(contents);
  builder_.add_error(error);
  builder_.add_contents_type(contents_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponsePacket> CreateResponsePacketDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *error = nullptr,
    bpio::ResponsePacketContents contents_type = bpio::ResponsePacketContents_NONE,
    ::flatbuffers::Offset<void> contents = 0) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return bpio::CreateResponsePacket(
      _fbb,
      error__,
      contents_type,
      contents);
}

inline bool VerifyEquipment(::flatbuffers::Verifier &verifier, const void *obj, Equipment type) {
  switch (type) {
    case Equipment_NONE: {
      return true;
    }
    case Equipment_Weapon: {
      auto ptr = reinterpret_cast<const bpio::Weapon *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyEquipmentVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEquipment(
        verifier,  values->Get(i), types->GetEnum<Equipment>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyRequestPacketContents(::flatbuffers::Verifier &verifier, const void *obj, RequestPacketContents type) {
  switch (type) {
    case RequestPacketContents_NONE: {
      return true;
    }
    case RequestPacketContents_Monster: {
      auto ptr = reinterpret_cast<const bpio::Monster *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPacketContents_StatusRequest: {
      auto ptr = reinterpret_cast<const bpio::StatusRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPacketContents_ConfigurationRequest: {
      auto ptr = reinterpret_cast<const bpio::ConfigurationRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPacketContents_DataRequest: {
      auto ptr = reinterpret_cast<const bpio::DataRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRequestPacketContentsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRequestPacketContents(
        verifier,  values->Get(i), types->GetEnum<RequestPacketContents>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyResponsePacketContents(::flatbuffers::Verifier &verifier, const void *obj, ResponsePacketContents type) {
  switch (type) {
    case ResponsePacketContents_NONE: {
      return true;
    }
    case ResponsePacketContents_ErrorResponse: {
      auto ptr = reinterpret_cast<const bpio::ErrorResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePacketContents_Monster: {
      auto ptr = reinterpret_cast<const bpio::Monster *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePacketContents_ConfigurationResponse: {
      auto ptr = reinterpret_cast<const bpio::ConfigurationResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePacketContents_StatusResponse: {
      auto ptr = reinterpret_cast<const bpio::StatusResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePacketContents_DataResponse: {
      auto ptr = reinterpret_cast<const bpio::DataResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyResponsePacketContentsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResponsePacketContents(
        verifier,  values->Get(i), types->GetEnum<ResponsePacketContents>(i))) {
      return false;
    }
  }
  return true;
}

inline const bpio::ResponsePacket *GetResponsePacket(const void *buf) {
  return ::flatbuffers::GetRoot<bpio::ResponsePacket>(buf);
}

inline const bpio::ResponsePacket *GetSizePrefixedResponsePacket(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<bpio::ResponsePacket>(buf);
}

inline bool VerifyResponsePacketBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<bpio::ResponsePacket>(nullptr);
}

inline bool VerifySizePrefixedResponsePacketBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<bpio::ResponsePacket>(nullptr);
}

inline void FinishResponsePacketBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<bpio::ResponsePacket> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedResponsePacketBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<bpio::ResponsePacket> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace bpio

#endif  // FLATBUFFERS_GENERATED_BPIO_BPIO_H_
