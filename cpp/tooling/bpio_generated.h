// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BPIO_BPIO_H_
#define FLATBUFFERS_GENERATED_BPIO_BPIO_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace bpio {

struct StatusRequest;
struct StatusRequestBuilder;

struct StatusResponse;
struct StatusResponseBuilder;

struct ModeConfiguration;
struct ModeConfigurationBuilder;

struct ConfigurationRequest;
struct ConfigurationRequestBuilder;

struct ConfigurationResponse;
struct ConfigurationResponseBuilder;

struct DataRequest;
struct DataRequestBuilder;

struct DataResponse;
struct DataResponseBuilder;

struct ErrorResponse;
struct ErrorResponseBuilder;

struct RequestPacket;
struct RequestPacketBuilder;

struct ResponsePacket;
struct ResponsePacketBuilder;

enum StatusRequestTypes : int8_t {
  StatusRequestTypes_All = 0,
  StatusRequestTypes_Version = 1,
  StatusRequestTypes_Mode = 2,
  StatusRequestTypes_Pullup = 3,
  StatusRequestTypes_PSU = 4,
  StatusRequestTypes_ADC = 5,
  StatusRequestTypes_IO = 6,
  StatusRequestTypes_Disk = 7,
  StatusRequestTypes_LED = 8,
  StatusRequestTypes_MIN = StatusRequestTypes_All,
  StatusRequestTypes_MAX = StatusRequestTypes_LED
};

inline const StatusRequestTypes (&EnumValuesStatusRequestTypes())[9] {
  static const StatusRequestTypes values[] = {
    StatusRequestTypes_All,
    StatusRequestTypes_Version,
    StatusRequestTypes_Mode,
    StatusRequestTypes_Pullup,
    StatusRequestTypes_PSU,
    StatusRequestTypes_ADC,
    StatusRequestTypes_IO,
    StatusRequestTypes_Disk,
    StatusRequestTypes_LED
  };
  return values;
}

inline const char * const *EnumNamesStatusRequestTypes() {
  static const char * const names[10] = {
    "All",
    "Version",
    "Mode",
    "Pullup",
    "PSU",
    "ADC",
    "IO",
    "Disk",
    "LED",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatusRequestTypes(StatusRequestTypes e) {
  if (::flatbuffers::IsOutRange(e, StatusRequestTypes_All, StatusRequestTypes_LED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatusRequestTypes()[index];
}

enum RequestPacketContents : uint8_t {
  RequestPacketContents_NONE = 0,
  RequestPacketContents_StatusRequest = 1,
  RequestPacketContents_ConfigurationRequest = 2,
  RequestPacketContents_DataRequest = 3,
  RequestPacketContents_MIN = RequestPacketContents_NONE,
  RequestPacketContents_MAX = RequestPacketContents_DataRequest
};

inline const RequestPacketContents (&EnumValuesRequestPacketContents())[4] {
  static const RequestPacketContents values[] = {
    RequestPacketContents_NONE,
    RequestPacketContents_StatusRequest,
    RequestPacketContents_ConfigurationRequest,
    RequestPacketContents_DataRequest
  };
  return values;
}

inline const char * const *EnumNamesRequestPacketContents() {
  static const char * const names[5] = {
    "NONE",
    "StatusRequest",
    "ConfigurationRequest",
    "DataRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestPacketContents(RequestPacketContents e) {
  if (::flatbuffers::IsOutRange(e, RequestPacketContents_NONE, RequestPacketContents_DataRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestPacketContents()[index];
}

template<typename T> struct RequestPacketContentsTraits {
  static const RequestPacketContents enum_value = RequestPacketContents_NONE;
};

template<> struct RequestPacketContentsTraits<bpio::StatusRequest> {
  static const RequestPacketContents enum_value = RequestPacketContents_StatusRequest;
};

template<> struct RequestPacketContentsTraits<bpio::ConfigurationRequest> {
  static const RequestPacketContents enum_value = RequestPacketContents_ConfigurationRequest;
};

template<> struct RequestPacketContentsTraits<bpio::DataRequest> {
  static const RequestPacketContents enum_value = RequestPacketContents_DataRequest;
};

bool VerifyRequestPacketContents(::flatbuffers::Verifier &verifier, const void *obj, RequestPacketContents type);
bool VerifyRequestPacketContentsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum ResponsePacketContents : uint8_t {
  ResponsePacketContents_NONE = 0,
  ResponsePacketContents_ErrorResponse = 1,
  ResponsePacketContents_StatusResponse = 2,
  ResponsePacketContents_ConfigurationResponse = 3,
  ResponsePacketContents_DataResponse = 4,
  ResponsePacketContents_MIN = ResponsePacketContents_NONE,
  ResponsePacketContents_MAX = ResponsePacketContents_DataResponse
};

inline const ResponsePacketContents (&EnumValuesResponsePacketContents())[5] {
  static const ResponsePacketContents values[] = {
    ResponsePacketContents_NONE,
    ResponsePacketContents_ErrorResponse,
    ResponsePacketContents_StatusResponse,
    ResponsePacketContents_ConfigurationResponse,
    ResponsePacketContents_DataResponse
  };
  return values;
}

inline const char * const *EnumNamesResponsePacketContents() {
  static const char * const names[6] = {
    "NONE",
    "ErrorResponse",
    "StatusResponse",
    "ConfigurationResponse",
    "DataResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponsePacketContents(ResponsePacketContents e) {
  if (::flatbuffers::IsOutRange(e, ResponsePacketContents_NONE, ResponsePacketContents_DataResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResponsePacketContents()[index];
}

template<typename T> struct ResponsePacketContentsTraits {
  static const ResponsePacketContents enum_value = ResponsePacketContents_NONE;
};

template<> struct ResponsePacketContentsTraits<bpio::ErrorResponse> {
  static const ResponsePacketContents enum_value = ResponsePacketContents_ErrorResponse;
};

template<> struct ResponsePacketContentsTraits<bpio::StatusResponse> {
  static const ResponsePacketContents enum_value = ResponsePacketContents_StatusResponse;
};

template<> struct ResponsePacketContentsTraits<bpio::ConfigurationResponse> {
  static const ResponsePacketContents enum_value = ResponsePacketContents_ConfigurationResponse;
};

template<> struct ResponsePacketContentsTraits<bpio::DataResponse> {
  static const ResponsePacketContents enum_value = ResponsePacketContents_DataResponse;
};

bool VerifyResponsePacketContents(::flatbuffers::Verifier &verifier, const void *obj, ResponsePacketContents type);
bool VerifyResponsePacketContentsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct StatusRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatusRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_QUERY = 4
  };
  const ::flatbuffers::Vector<int8_t> *query() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_QUERY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_QUERY) &&
           verifier.VerifyVector(query()) &&
           verifier.EndTable();
  }
};

struct StatusRequestBuilder {
  typedef StatusRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_query(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> query) {
    fbb_.AddOffset(StatusRequest::VT_QUERY, query);
  }
  explicit StatusRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StatusRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StatusRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StatusRequest> CreateStatusRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> query = 0) {
  StatusRequestBuilder builder_(_fbb);
  builder_.add_query(query);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StatusRequest> CreateStatusRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *query = nullptr) {
  auto query__ = query ? _fbb.CreateVector<int8_t>(*query) : 0;
  return bpio::CreateStatusRequest(
      _fbb,
      query__);
}

struct StatusResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatusResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR = 4,
    VT_VERSION_HARDWARE_MAJOR = 6,
    VT_VERSION_HARDWARE_MINOR = 8,
    VT_VERSION_FIRMWARE_MAJOR = 10,
    VT_VERSION_FIRMWARE_MINOR = 12,
    VT_VERSION_FIRMWARE_GIT_HASH = 14,
    VT_VERSION_FIRMWARE_DATE = 16,
    VT_MODES_AVAILABLE = 18,
    VT_MODE_CURRENT = 20,
    VT_MODE_PIN_LABELS = 22,
    VT_MODE_BITORDER_MSB = 24,
    VT_MODE_MAX_PACKET_SIZE = 26,
    VT_MODE_MAX_WRITE = 28,
    VT_MODE_MAX_READ = 30,
    VT_PSU_ENABLED = 32,
    VT_PSU_SET_MV = 34,
    VT_PSU_SET_MA = 36,
    VT_PSU_MEASURED_MV = 38,
    VT_PSU_MEASURED_MA = 40,
    VT_PSU_CURRENT_ERROR = 42,
    VT_PULLUP_ENABLED = 44,
    VT_ADC_MV = 46,
    VT_IO_DIRECTION = 48,
    VT_IO_VALUE = 50,
    VT_DISK_SIZE_MB = 52,
    VT_DISK_USED_MB = 54,
    VT_LED_COUNT = 56
  };
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  uint8_t version_hardware_major() const {
    return GetField<uint8_t>(VT_VERSION_HARDWARE_MAJOR, 0);
  }
  uint8_t version_hardware_minor() const {
    return GetField<uint8_t>(VT_VERSION_HARDWARE_MINOR, 0);
  }
  uint8_t version_firmware_major() const {
    return GetField<uint8_t>(VT_VERSION_FIRMWARE_MAJOR, 0);
  }
  uint8_t version_firmware_minor() const {
    return GetField<uint8_t>(VT_VERSION_FIRMWARE_MINOR, 0);
  }
  const ::flatbuffers::String *version_firmware_git_hash() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION_FIRMWARE_GIT_HASH);
  }
  const ::flatbuffers::String *version_firmware_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION_FIRMWARE_DATE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *modes_available() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MODES_AVAILABLE);
  }
  const ::flatbuffers::String *mode_current() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MODE_CURRENT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mode_pin_labels() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MODE_PIN_LABELS);
  }
  bool mode_bitorder_msb() const {
    return GetField<uint8_t>(VT_MODE_BITORDER_MSB, 0) != 0;
  }
  uint32_t mode_max_packet_size() const {
    return GetField<uint32_t>(VT_MODE_MAX_PACKET_SIZE, 0);
  }
  uint32_t mode_max_write() const {
    return GetField<uint32_t>(VT_MODE_MAX_WRITE, 0);
  }
  uint32_t mode_max_read() const {
    return GetField<uint32_t>(VT_MODE_MAX_READ, 0);
  }
  bool psu_enabled() const {
    return GetField<uint8_t>(VT_PSU_ENABLED, 0) != 0;
  }
  uint32_t psu_set_mv() const {
    return GetField<uint32_t>(VT_PSU_SET_MV, 0);
  }
  uint32_t psu_set_ma() const {
    return GetField<uint32_t>(VT_PSU_SET_MA, 0);
  }
  uint32_t psu_measured_mv() const {
    return GetField<uint32_t>(VT_PSU_MEASURED_MV, 0);
  }
  uint32_t psu_measured_ma() const {
    return GetField<uint32_t>(VT_PSU_MEASURED_MA, 0);
  }
  bool psu_current_error() const {
    return GetField<uint8_t>(VT_PSU_CURRENT_ERROR, 0) != 0;
  }
  bool pullup_enabled() const {
    return GetField<uint8_t>(VT_PULLUP_ENABLED, 0) != 0;
  }
  const ::flatbuffers::Vector<uint32_t> *adc_mv() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_ADC_MV);
  }
  uint8_t io_direction() const {
    return GetField<uint8_t>(VT_IO_DIRECTION, 0);
  }
  uint8_t io_value() const {
    return GetField<uint8_t>(VT_IO_VALUE, 0);
  }
  float disk_size_mb() const {
    return GetField<float>(VT_DISK_SIZE_MB, 0.0f);
  }
  float disk_used_mb() const {
    return GetField<float>(VT_DISK_USED_MB, 0.0f);
  }
  uint8_t led_count() const {
    return GetField<uint8_t>(VT_LED_COUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           VerifyField<uint8_t>(verifier, VT_VERSION_HARDWARE_MAJOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_VERSION_HARDWARE_MINOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_VERSION_FIRMWARE_MAJOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_VERSION_FIRMWARE_MINOR, 1) &&
           VerifyOffset(verifier, VT_VERSION_FIRMWARE_GIT_HASH) &&
           verifier.VerifyString(version_firmware_git_hash()) &&
           VerifyOffset(verifier, VT_VERSION_FIRMWARE_DATE) &&
           verifier.VerifyString(version_firmware_date()) &&
           VerifyOffset(verifier, VT_MODES_AVAILABLE) &&
           verifier.VerifyVector(modes_available()) &&
           verifier.VerifyVectorOfStrings(modes_available()) &&
           VerifyOffset(verifier, VT_MODE_CURRENT) &&
           verifier.VerifyString(mode_current()) &&
           VerifyOffset(verifier, VT_MODE_PIN_LABELS) &&
           verifier.VerifyVector(mode_pin_labels()) &&
           verifier.VerifyVectorOfStrings(mode_pin_labels()) &&
           VerifyField<uint8_t>(verifier, VT_MODE_BITORDER_MSB, 1) &&
           VerifyField<uint32_t>(verifier, VT_MODE_MAX_PACKET_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_MODE_MAX_WRITE, 4) &&
           VerifyField<uint32_t>(verifier, VT_MODE_MAX_READ, 4) &&
           VerifyField<uint8_t>(verifier, VT_PSU_ENABLED, 1) &&
           VerifyField<uint32_t>(verifier, VT_PSU_SET_MV, 4) &&
           VerifyField<uint32_t>(verifier, VT_PSU_SET_MA, 4) &&
           VerifyField<uint32_t>(verifier, VT_PSU_MEASURED_MV, 4) &&
           VerifyField<uint32_t>(verifier, VT_PSU_MEASURED_MA, 4) &&
           VerifyField<uint8_t>(verifier, VT_PSU_CURRENT_ERROR, 1) &&
           VerifyField<uint8_t>(verifier, VT_PULLUP_ENABLED, 1) &&
           VerifyOffset(verifier, VT_ADC_MV) &&
           verifier.VerifyVector(adc_mv()) &&
           VerifyField<uint8_t>(verifier, VT_IO_DIRECTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_IO_VALUE, 1) &&
           VerifyField<float>(verifier, VT_DISK_SIZE_MB, 4) &&
           VerifyField<float>(verifier, VT_DISK_USED_MB, 4) &&
           VerifyField<uint8_t>(verifier, VT_LED_COUNT, 1) &&
           verifier.EndTable();
  }
};

struct StatusResponseBuilder {
  typedef StatusResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(StatusResponse::VT_ERROR, error);
  }
  void add_version_hardware_major(uint8_t version_hardware_major) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_VERSION_HARDWARE_MAJOR, version_hardware_major, 0);
  }
  void add_version_hardware_minor(uint8_t version_hardware_minor) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_VERSION_HARDWARE_MINOR, version_hardware_minor, 0);
  }
  void add_version_firmware_major(uint8_t version_firmware_major) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_VERSION_FIRMWARE_MAJOR, version_firmware_major, 0);
  }
  void add_version_firmware_minor(uint8_t version_firmware_minor) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_VERSION_FIRMWARE_MINOR, version_firmware_minor, 0);
  }
  void add_version_firmware_git_hash(::flatbuffers::Offset<::flatbuffers::String> version_firmware_git_hash) {
    fbb_.AddOffset(StatusResponse::VT_VERSION_FIRMWARE_GIT_HASH, version_firmware_git_hash);
  }
  void add_version_firmware_date(::flatbuffers::Offset<::flatbuffers::String> version_firmware_date) {
    fbb_.AddOffset(StatusResponse::VT_VERSION_FIRMWARE_DATE, version_firmware_date);
  }
  void add_modes_available(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> modes_available) {
    fbb_.AddOffset(StatusResponse::VT_MODES_AVAILABLE, modes_available);
  }
  void add_mode_current(::flatbuffers::Offset<::flatbuffers::String> mode_current) {
    fbb_.AddOffset(StatusResponse::VT_MODE_CURRENT, mode_current);
  }
  void add_mode_pin_labels(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> mode_pin_labels) {
    fbb_.AddOffset(StatusResponse::VT_MODE_PIN_LABELS, mode_pin_labels);
  }
  void add_mode_bitorder_msb(bool mode_bitorder_msb) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_MODE_BITORDER_MSB, static_cast<uint8_t>(mode_bitorder_msb), 0);
  }
  void add_mode_max_packet_size(uint32_t mode_max_packet_size) {
    fbb_.AddElement<uint32_t>(StatusResponse::VT_MODE_MAX_PACKET_SIZE, mode_max_packet_size, 0);
  }
  void add_mode_max_write(uint32_t mode_max_write) {
    fbb_.AddElement<uint32_t>(StatusResponse::VT_MODE_MAX_WRITE, mode_max_write, 0);
  }
  void add_mode_max_read(uint32_t mode_max_read) {
    fbb_.AddElement<uint32_t>(StatusResponse::VT_MODE_MAX_READ, mode_max_read, 0);
  }
  void add_psu_enabled(bool psu_enabled) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_PSU_ENABLED, static_cast<uint8_t>(psu_enabled), 0);
  }
  void add_psu_set_mv(uint32_t psu_set_mv) {
    fbb_.AddElement<uint32_t>(StatusResponse::VT_PSU_SET_MV, psu_set_mv, 0);
  }
  void add_psu_set_ma(uint32_t psu_set_ma) {
    fbb_.AddElement<uint32_t>(StatusResponse::VT_PSU_SET_MA, psu_set_ma, 0);
  }
  void add_psu_measured_mv(uint32_t psu_measured_mv) {
    fbb_.AddElement<uint32_t>(StatusResponse::VT_PSU_MEASURED_MV, psu_measured_mv, 0);
  }
  void add_psu_measured_ma(uint32_t psu_measured_ma) {
    fbb_.AddElement<uint32_t>(StatusResponse::VT_PSU_MEASURED_MA, psu_measured_ma, 0);
  }
  void add_psu_current_error(bool psu_current_error) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_PSU_CURRENT_ERROR, static_cast<uint8_t>(psu_current_error), 0);
  }
  void add_pullup_enabled(bool pullup_enabled) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_PULLUP_ENABLED, static_cast<uint8_t>(pullup_enabled), 0);
  }
  void add_adc_mv(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> adc_mv) {
    fbb_.AddOffset(StatusResponse::VT_ADC_MV, adc_mv);
  }
  void add_io_direction(uint8_t io_direction) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_IO_DIRECTION, io_direction, 0);
  }
  void add_io_value(uint8_t io_value) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_IO_VALUE, io_value, 0);
  }
  void add_disk_size_mb(float disk_size_mb) {
    fbb_.AddElement<float>(StatusResponse::VT_DISK_SIZE_MB, disk_size_mb, 0.0f);
  }
  void add_disk_used_mb(float disk_used_mb) {
    fbb_.AddElement<float>(StatusResponse::VT_DISK_USED_MB, disk_used_mb, 0.0f);
  }
  void add_led_count(uint8_t led_count) {
    fbb_.AddElement<uint8_t>(StatusResponse::VT_LED_COUNT, led_count, 0);
  }
  explicit StatusResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StatusResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StatusResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StatusResponse> CreateStatusResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0,
    uint8_t version_hardware_major = 0,
    uint8_t version_hardware_minor = 0,
    uint8_t version_firmware_major = 0,
    uint8_t version_firmware_minor = 0,
    ::flatbuffers::Offset<::flatbuffers::String> version_firmware_git_hash = 0,
    ::flatbuffers::Offset<::flatbuffers::String> version_firmware_date = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> modes_available = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mode_current = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> mode_pin_labels = 0,
    bool mode_bitorder_msb = false,
    uint32_t mode_max_packet_size = 0,
    uint32_t mode_max_write = 0,
    uint32_t mode_max_read = 0,
    bool psu_enabled = false,
    uint32_t psu_set_mv = 0,
    uint32_t psu_set_ma = 0,
    uint32_t psu_measured_mv = 0,
    uint32_t psu_measured_ma = 0,
    bool psu_current_error = false,
    bool pullup_enabled = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> adc_mv = 0,
    uint8_t io_direction = 0,
    uint8_t io_value = 0,
    float disk_size_mb = 0.0f,
    float disk_used_mb = 0.0f,
    uint8_t led_count = 0) {
  StatusResponseBuilder builder_(_fbb);
  builder_.add_disk_used_mb(disk_used_mb);
  builder_.add_disk_size_mb(disk_size_mb);
  builder_.add_adc_mv(adc_mv);
  builder_.add_psu_measured_ma(psu_measured_ma);
  builder_.add_psu_measured_mv(psu_measured_mv);
  builder_.add_psu_set_ma(psu_set_ma);
  builder_.add_psu_set_mv(psu_set_mv);
  builder_.add_mode_max_read(mode_max_read);
  builder_.add_mode_max_write(mode_max_write);
  builder_.add_mode_max_packet_size(mode_max_packet_size);
  builder_.add_mode_pin_labels(mode_pin_labels);
  builder_.add_mode_current(mode_current);
  builder_.add_modes_available(modes_available);
  builder_.add_version_firmware_date(version_firmware_date);
  builder_.add_version_firmware_git_hash(version_firmware_git_hash);
  builder_.add_error(error);
  builder_.add_led_count(led_count);
  builder_.add_io_value(io_value);
  builder_.add_io_direction(io_direction);
  builder_.add_pullup_enabled(pullup_enabled);
  builder_.add_psu_current_error(psu_current_error);
  builder_.add_psu_enabled(psu_enabled);
  builder_.add_mode_bitorder_msb(mode_bitorder_msb);
  builder_.add_version_firmware_minor(version_firmware_minor);
  builder_.add_version_firmware_major(version_firmware_major);
  builder_.add_version_hardware_minor(version_hardware_minor);
  builder_.add_version_hardware_major(version_hardware_major);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StatusResponse> CreateStatusResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *error = nullptr,
    uint8_t version_hardware_major = 0,
    uint8_t version_hardware_minor = 0,
    uint8_t version_firmware_major = 0,
    uint8_t version_firmware_minor = 0,
    const char *version_firmware_git_hash = nullptr,
    const char *version_firmware_date = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *modes_available = nullptr,
    const char *mode_current = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *mode_pin_labels = nullptr,
    bool mode_bitorder_msb = false,
    uint32_t mode_max_packet_size = 0,
    uint32_t mode_max_write = 0,
    uint32_t mode_max_read = 0,
    bool psu_enabled = false,
    uint32_t psu_set_mv = 0,
    uint32_t psu_set_ma = 0,
    uint32_t psu_measured_mv = 0,
    uint32_t psu_measured_ma = 0,
    bool psu_current_error = false,
    bool pullup_enabled = false,
    const std::vector<uint32_t> *adc_mv = nullptr,
    uint8_t io_direction = 0,
    uint8_t io_value = 0,
    float disk_size_mb = 0.0f,
    float disk_used_mb = 0.0f,
    uint8_t led_count = 0) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  auto version_firmware_git_hash__ = version_firmware_git_hash ? _fbb.CreateString(version_firmware_git_hash) : 0;
  auto version_firmware_date__ = version_firmware_date ? _fbb.CreateString(version_firmware_date) : 0;
  auto modes_available__ = modes_available ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*modes_available) : 0;
  auto mode_current__ = mode_current ? _fbb.CreateString(mode_current) : 0;
  auto mode_pin_labels__ = mode_pin_labels ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*mode_pin_labels) : 0;
  auto adc_mv__ = adc_mv ? _fbb.CreateVector<uint32_t>(*adc_mv) : 0;
  return bpio::CreateStatusResponse(
      _fbb,
      error__,
      version_hardware_major,
      version_hardware_minor,
      version_firmware_major,
      version_firmware_minor,
      version_firmware_git_hash__,
      version_firmware_date__,
      modes_available__,
      mode_current__,
      mode_pin_labels__,
      mode_bitorder_msb,
      mode_max_packet_size,
      mode_max_write,
      mode_max_read,
      psu_enabled,
      psu_set_mv,
      psu_set_ma,
      psu_measured_mv,
      psu_measured_ma,
      psu_current_error,
      pullup_enabled,
      adc_mv__,
      io_direction,
      io_value,
      disk_size_mb,
      disk_used_mb,
      led_count);
}

struct ModeConfiguration FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModeConfigurationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPEED = 4,
    VT_DATA_BITS = 6,
    VT_PARITY = 8,
    VT_STOP_BITS = 10,
    VT_FLOW_CONTROL = 12,
    VT_SIGNAL_INVERSION = 14,
    VT_CLOCK_STRETCH = 16,
    VT_CLOCK_POLARITY = 18,
    VT_CLOCK_PHASE = 20,
    VT_CHIP_SELECT_IDLE = 22,
    VT_SUBMODE = 24,
    VT_TX_MODULATION = 26,
    VT_RX_SENSOR = 28
  };
  uint32_t speed() const {
    return GetField<uint32_t>(VT_SPEED, 20000);
  }
  uint8_t data_bits() const {
    return GetField<uint8_t>(VT_DATA_BITS, 8);
  }
  bool parity() const {
    return GetField<uint8_t>(VT_PARITY, 0) != 0;
  }
  uint8_t stop_bits() const {
    return GetField<uint8_t>(VT_STOP_BITS, 1);
  }
  bool flow_control() const {
    return GetField<uint8_t>(VT_FLOW_CONTROL, 0) != 0;
  }
  bool signal_inversion() const {
    return GetField<uint8_t>(VT_SIGNAL_INVERSION, 0) != 0;
  }
  bool clock_stretch() const {
    return GetField<uint8_t>(VT_CLOCK_STRETCH, 0) != 0;
  }
  bool clock_polarity() const {
    return GetField<uint8_t>(VT_CLOCK_POLARITY, 0) != 0;
  }
  bool clock_phase() const {
    return GetField<uint8_t>(VT_CLOCK_PHASE, 0) != 0;
  }
  bool chip_select_idle() const {
    return GetField<uint8_t>(VT_CHIP_SELECT_IDLE, 1) != 0;
  }
  uint8_t submode() const {
    return GetField<uint8_t>(VT_SUBMODE, 0);
  }
  uint32_t tx_modulation() const {
    return GetField<uint32_t>(VT_TX_MODULATION, 0);
  }
  uint8_t rx_sensor() const {
    return GetField<uint8_t>(VT_RX_SENSOR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SPEED, 4) &&
           VerifyField<uint8_t>(verifier, VT_DATA_BITS, 1) &&
           VerifyField<uint8_t>(verifier, VT_PARITY, 1) &&
           VerifyField<uint8_t>(verifier, VT_STOP_BITS, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLOW_CONTROL, 1) &&
           VerifyField<uint8_t>(verifier, VT_SIGNAL_INVERSION, 1) &&
           VerifyField<uint8_t>(verifier, VT_CLOCK_STRETCH, 1) &&
           VerifyField<uint8_t>(verifier, VT_CLOCK_POLARITY, 1) &&
           VerifyField<uint8_t>(verifier, VT_CLOCK_PHASE, 1) &&
           VerifyField<uint8_t>(verifier, VT_CHIP_SELECT_IDLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_SUBMODE, 1) &&
           VerifyField<uint32_t>(verifier, VT_TX_MODULATION, 4) &&
           VerifyField<uint8_t>(verifier, VT_RX_SENSOR, 1) &&
           verifier.EndTable();
  }
};

struct ModeConfigurationBuilder {
  typedef ModeConfiguration Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_speed(uint32_t speed) {
    fbb_.AddElement<uint32_t>(ModeConfiguration::VT_SPEED, speed, 20000);
  }
  void add_data_bits(uint8_t data_bits) {
    fbb_.AddElement<uint8_t>(ModeConfiguration::VT_DATA_BITS, data_bits, 8);
  }
  void add_parity(bool parity) {
    fbb_.AddElement<uint8_t>(ModeConfiguration::VT_PARITY, static_cast<uint8_t>(parity), 0);
  }
  void add_stop_bits(uint8_t stop_bits) {
    fbb_.AddElement<uint8_t>(ModeConfiguration::VT_STOP_BITS, stop_bits, 1);
  }
  void add_flow_control(bool flow_control) {
    fbb_.AddElement<uint8_t>(ModeConfiguration::VT_FLOW_CONTROL, static_cast<uint8_t>(flow_control), 0);
  }
  void add_signal_inversion(bool signal_inversion) {
    fbb_.AddElement<uint8_t>(ModeConfiguration::VT_SIGNAL_INVERSION, static_cast<uint8_t>(signal_inversion), 0);
  }
  void add_clock_stretch(bool clock_stretch) {
    fbb_.AddElement<uint8_t>(ModeConfiguration::VT_CLOCK_STRETCH, static_cast<uint8_t>(clock_stretch), 0);
  }
  void add_clock_polarity(bool clock_polarity) {
    fbb_.AddElement<uint8_t>(ModeConfiguration::VT_CLOCK_POLARITY, static_cast<uint8_t>(clock_polarity), 0);
  }
  void add_clock_phase(bool clock_phase) {
    fbb_.AddElement<uint8_t>(ModeConfiguration::VT_CLOCK_PHASE, static_cast<uint8_t>(clock_phase), 0);
  }
  void add_chip_select_idle(bool chip_select_idle) {
    fbb_.AddElement<uint8_t>(ModeConfiguration::VT_CHIP_SELECT_IDLE, static_cast<uint8_t>(chip_select_idle), 1);
  }
  void add_submode(uint8_t submode) {
    fbb_.AddElement<uint8_t>(ModeConfiguration::VT_SUBMODE, submode, 0);
  }
  void add_tx_modulation(uint32_t tx_modulation) {
    fbb_.AddElement<uint32_t>(ModeConfiguration::VT_TX_MODULATION, tx_modulation, 0);
  }
  void add_rx_sensor(uint8_t rx_sensor) {
    fbb_.AddElement<uint8_t>(ModeConfiguration::VT_RX_SENSOR, rx_sensor, 0);
  }
  explicit ModeConfigurationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ModeConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ModeConfiguration>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ModeConfiguration> CreateModeConfiguration(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t speed = 20000,
    uint8_t data_bits = 8,
    bool parity = false,
    uint8_t stop_bits = 1,
    bool flow_control = false,
    bool signal_inversion = false,
    bool clock_stretch = false,
    bool clock_polarity = false,
    bool clock_phase = false,
    bool chip_select_idle = true,
    uint8_t submode = 0,
    uint32_t tx_modulation = 0,
    uint8_t rx_sensor = 0) {
  ModeConfigurationBuilder builder_(_fbb);
  builder_.add_tx_modulation(tx_modulation);
  builder_.add_speed(speed);
  builder_.add_rx_sensor(rx_sensor);
  builder_.add_submode(submode);
  builder_.add_chip_select_idle(chip_select_idle);
  builder_.add_clock_phase(clock_phase);
  builder_.add_clock_polarity(clock_polarity);
  builder_.add_clock_stretch(clock_stretch);
  builder_.add_signal_inversion(signal_inversion);
  builder_.add_flow_control(flow_control);
  builder_.add_stop_bits(stop_bits);
  builder_.add_parity(parity);
  builder_.add_data_bits(data_bits);
  return builder_.Finish();
}

struct ConfigurationRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConfigurationRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_MODE_CONFIGURATION = 6,
    VT_MODE_BITORDER_MSB = 8,
    VT_MODE_BITORDER_LSB = 10,
    VT_PSU_DISABLE = 12,
    VT_PSU_ENABLE = 14,
    VT_PSU_SET_MV = 16,
    VT_PSU_SET_MA = 18,
    VT_PULLUP_DISABLE = 20,
    VT_PULLUP_ENABLE = 22,
    VT_IO_DIRECTION_MASK = 24,
    VT_IO_DIRECTION = 26,
    VT_IO_VALUE_MASK = 28,
    VT_IO_VALUE = 30,
    VT_LED_RESUME = 32,
    VT_LED_COLOR = 34,
    VT_PRINT_STRING = 36,
    VT_HARDWARE_BOOTLOADER = 38,
    VT_HARDWARE_RESET = 40,
    VT_HARDWARE_SELFTEST = 42
  };
  const ::flatbuffers::String *mode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MODE);
  }
  const bpio::ModeConfiguration *mode_configuration() const {
    return GetPointer<const bpio::ModeConfiguration *>(VT_MODE_CONFIGURATION);
  }
  bool mode_bitorder_msb() const {
    return GetField<uint8_t>(VT_MODE_BITORDER_MSB, 0) != 0;
  }
  bool mode_bitorder_lsb() const {
    return GetField<uint8_t>(VT_MODE_BITORDER_LSB, 0) != 0;
  }
  bool psu_disable() const {
    return GetField<uint8_t>(VT_PSU_DISABLE, 0) != 0;
  }
  bool psu_enable() const {
    return GetField<uint8_t>(VT_PSU_ENABLE, 0) != 0;
  }
  uint32_t psu_set_mv() const {
    return GetField<uint32_t>(VT_PSU_SET_MV, 0);
  }
  uint16_t psu_set_ma() const {
    return GetField<uint16_t>(VT_PSU_SET_MA, 300);
  }
  bool pullup_disable() const {
    return GetField<uint8_t>(VT_PULLUP_DISABLE, 0) != 0;
  }
  bool pullup_enable() const {
    return GetField<uint8_t>(VT_PULLUP_ENABLE, 0) != 0;
  }
  uint8_t io_direction_mask() const {
    return GetField<uint8_t>(VT_IO_DIRECTION_MASK, 0);
  }
  uint8_t io_direction() const {
    return GetField<uint8_t>(VT_IO_DIRECTION, 0);
  }
  uint8_t io_value_mask() const {
    return GetField<uint8_t>(VT_IO_VALUE_MASK, 0);
  }
  uint8_t io_value() const {
    return GetField<uint8_t>(VT_IO_VALUE, 0);
  }
  bool led_resume() const {
    return GetField<uint8_t>(VT_LED_RESUME, 0) != 0;
  }
  const ::flatbuffers::Vector<uint32_t> *led_color() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_LED_COLOR);
  }
  const ::flatbuffers::String *print_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRINT_STRING);
  }
  bool hardware_bootloader() const {
    return GetField<uint8_t>(VT_HARDWARE_BOOTLOADER, 0) != 0;
  }
  bool hardware_reset() const {
    return GetField<uint8_t>(VT_HARDWARE_RESET, 0) != 0;
  }
  bool hardware_selftest() const {
    return GetField<uint8_t>(VT_HARDWARE_SELFTEST, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODE) &&
           verifier.VerifyString(mode()) &&
           VerifyOffset(verifier, VT_MODE_CONFIGURATION) &&
           verifier.VerifyTable(mode_configuration()) &&
           VerifyField<uint8_t>(verifier, VT_MODE_BITORDER_MSB, 1) &&
           VerifyField<uint8_t>(verifier, VT_MODE_BITORDER_LSB, 1) &&
           VerifyField<uint8_t>(verifier, VT_PSU_DISABLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_PSU_ENABLE, 1) &&
           VerifyField<uint32_t>(verifier, VT_PSU_SET_MV, 4) &&
           VerifyField<uint16_t>(verifier, VT_PSU_SET_MA, 2) &&
           VerifyField<uint8_t>(verifier, VT_PULLUP_DISABLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_PULLUP_ENABLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_IO_DIRECTION_MASK, 1) &&
           VerifyField<uint8_t>(verifier, VT_IO_DIRECTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_IO_VALUE_MASK, 1) &&
           VerifyField<uint8_t>(verifier, VT_IO_VALUE, 1) &&
           VerifyField<uint8_t>(verifier, VT_LED_RESUME, 1) &&
           VerifyOffset(verifier, VT_LED_COLOR) &&
           verifier.VerifyVector(led_color()) &&
           VerifyOffset(verifier, VT_PRINT_STRING) &&
           verifier.VerifyString(print_string()) &&
           VerifyField<uint8_t>(verifier, VT_HARDWARE_BOOTLOADER, 1) &&
           VerifyField<uint8_t>(verifier, VT_HARDWARE_RESET, 1) &&
           VerifyField<uint8_t>(verifier, VT_HARDWARE_SELFTEST, 1) &&
           verifier.EndTable();
  }
};

struct ConfigurationRequestBuilder {
  typedef ConfigurationRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mode(::flatbuffers::Offset<::flatbuffers::String> mode) {
    fbb_.AddOffset(ConfigurationRequest::VT_MODE, mode);
  }
  void add_mode_configuration(::flatbuffers::Offset<bpio::ModeConfiguration> mode_configuration) {
    fbb_.AddOffset(ConfigurationRequest::VT_MODE_CONFIGURATION, mode_configuration);
  }
  void add_mode_bitorder_msb(bool mode_bitorder_msb) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_MODE_BITORDER_MSB, static_cast<uint8_t>(mode_bitorder_msb), 0);
  }
  void add_mode_bitorder_lsb(bool mode_bitorder_lsb) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_MODE_BITORDER_LSB, static_cast<uint8_t>(mode_bitorder_lsb), 0);
  }
  void add_psu_disable(bool psu_disable) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_PSU_DISABLE, static_cast<uint8_t>(psu_disable), 0);
  }
  void add_psu_enable(bool psu_enable) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_PSU_ENABLE, static_cast<uint8_t>(psu_enable), 0);
  }
  void add_psu_set_mv(uint32_t psu_set_mv) {
    fbb_.AddElement<uint32_t>(ConfigurationRequest::VT_PSU_SET_MV, psu_set_mv, 0);
  }
  void add_psu_set_ma(uint16_t psu_set_ma) {
    fbb_.AddElement<uint16_t>(ConfigurationRequest::VT_PSU_SET_MA, psu_set_ma, 300);
  }
  void add_pullup_disable(bool pullup_disable) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_PULLUP_DISABLE, static_cast<uint8_t>(pullup_disable), 0);
  }
  void add_pullup_enable(bool pullup_enable) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_PULLUP_ENABLE, static_cast<uint8_t>(pullup_enable), 0);
  }
  void add_io_direction_mask(uint8_t io_direction_mask) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_IO_DIRECTION_MASK, io_direction_mask, 0);
  }
  void add_io_direction(uint8_t io_direction) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_IO_DIRECTION, io_direction, 0);
  }
  void add_io_value_mask(uint8_t io_value_mask) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_IO_VALUE_MASK, io_value_mask, 0);
  }
  void add_io_value(uint8_t io_value) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_IO_VALUE, io_value, 0);
  }
  void add_led_resume(bool led_resume) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_LED_RESUME, static_cast<uint8_t>(led_resume), 0);
  }
  void add_led_color(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> led_color) {
    fbb_.AddOffset(ConfigurationRequest::VT_LED_COLOR, led_color);
  }
  void add_print_string(::flatbuffers::Offset<::flatbuffers::String> print_string) {
    fbb_.AddOffset(ConfigurationRequest::VT_PRINT_STRING, print_string);
  }
  void add_hardware_bootloader(bool hardware_bootloader) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_HARDWARE_BOOTLOADER, static_cast<uint8_t>(hardware_bootloader), 0);
  }
  void add_hardware_reset(bool hardware_reset) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_HARDWARE_RESET, static_cast<uint8_t>(hardware_reset), 0);
  }
  void add_hardware_selftest(bool hardware_selftest) {
    fbb_.AddElement<uint8_t>(ConfigurationRequest::VT_HARDWARE_SELFTEST, static_cast<uint8_t>(hardware_selftest), 0);
  }
  explicit ConfigurationRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConfigurationRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConfigurationRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConfigurationRequest> CreateConfigurationRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> mode = 0,
    ::flatbuffers::Offset<bpio::ModeConfiguration> mode_configuration = 0,
    bool mode_bitorder_msb = false,
    bool mode_bitorder_lsb = false,
    bool psu_disable = false,
    bool psu_enable = false,
    uint32_t psu_set_mv = 0,
    uint16_t psu_set_ma = 300,
    bool pullup_disable = false,
    bool pullup_enable = false,
    uint8_t io_direction_mask = 0,
    uint8_t io_direction = 0,
    uint8_t io_value_mask = 0,
    uint8_t io_value = 0,
    bool led_resume = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> led_color = 0,
    ::flatbuffers::Offset<::flatbuffers::String> print_string = 0,
    bool hardware_bootloader = false,
    bool hardware_reset = false,
    bool hardware_selftest = false) {
  ConfigurationRequestBuilder builder_(_fbb);
  builder_.add_print_string(print_string);
  builder_.add_led_color(led_color);
  builder_.add_psu_set_mv(psu_set_mv);
  builder_.add_mode_configuration(mode_configuration);
  builder_.add_mode(mode);
  builder_.add_psu_set_ma(psu_set_ma);
  builder_.add_hardware_selftest(hardware_selftest);
  builder_.add_hardware_reset(hardware_reset);
  builder_.add_hardware_bootloader(hardware_bootloader);
  builder_.add_led_resume(led_resume);
  builder_.add_io_value(io_value);
  builder_.add_io_value_mask(io_value_mask);
  builder_.add_io_direction(io_direction);
  builder_.add_io_direction_mask(io_direction_mask);
  builder_.add_pullup_enable(pullup_enable);
  builder_.add_pullup_disable(pullup_disable);
  builder_.add_psu_enable(psu_enable);
  builder_.add_psu_disable(psu_disable);
  builder_.add_mode_bitorder_lsb(mode_bitorder_lsb);
  builder_.add_mode_bitorder_msb(mode_bitorder_msb);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConfigurationRequest> CreateConfigurationRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *mode = nullptr,
    ::flatbuffers::Offset<bpio::ModeConfiguration> mode_configuration = 0,
    bool mode_bitorder_msb = false,
    bool mode_bitorder_lsb = false,
    bool psu_disable = false,
    bool psu_enable = false,
    uint32_t psu_set_mv = 0,
    uint16_t psu_set_ma = 300,
    bool pullup_disable = false,
    bool pullup_enable = false,
    uint8_t io_direction_mask = 0,
    uint8_t io_direction = 0,
    uint8_t io_value_mask = 0,
    uint8_t io_value = 0,
    bool led_resume = false,
    const std::vector<uint32_t> *led_color = nullptr,
    const char *print_string = nullptr,
    bool hardware_bootloader = false,
    bool hardware_reset = false,
    bool hardware_selftest = false) {
  auto mode__ = mode ? _fbb.CreateString(mode) : 0;
  auto led_color__ = led_color ? _fbb.CreateVector<uint32_t>(*led_color) : 0;
  auto print_string__ = print_string ? _fbb.CreateString(print_string) : 0;
  return bpio::CreateConfigurationRequest(
      _fbb,
      mode__,
      mode_configuration,
      mode_bitorder_msb,
      mode_bitorder_lsb,
      psu_disable,
      psu_enable,
      psu_set_mv,
      psu_set_ma,
      pullup_disable,
      pullup_enable,
      io_direction_mask,
      io_direction,
      io_value_mask,
      io_value,
      led_resume,
      led_color__,
      print_string__,
      hardware_bootloader,
      hardware_reset,
      hardware_selftest);
}

struct ConfigurationResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConfigurationResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR = 4
  };
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
};

struct ConfigurationResponseBuilder {
  typedef ConfigurationResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(ConfigurationResponse::VT_ERROR, error);
  }
  explicit ConfigurationResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConfigurationResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConfigurationResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConfigurationResponse> CreateConfigurationResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0) {
  ConfigurationResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConfigurationResponse> CreateConfigurationResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *error = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return bpio::CreateConfigurationResponse(
      _fbb,
      error__);
}

struct DataRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DataRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_MAIN = 4,
    VT_START_ALT = 6,
    VT_DATA_WRITE = 8,
    VT_BYTES_READ = 10,
    VT_STOP_MAIN = 12,
    VT_STOP_ALT = 14
  };
  bool start_main() const {
    return GetField<uint8_t>(VT_START_MAIN, 0) != 0;
  }
  bool start_alt() const {
    return GetField<uint8_t>(VT_START_ALT, 0) != 0;
  }
  const ::flatbuffers::Vector<uint8_t> *data_write() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA_WRITE);
  }
  uint16_t bytes_read() const {
    return GetField<uint16_t>(VT_BYTES_READ, 0);
  }
  bool stop_main() const {
    return GetField<uint8_t>(VT_STOP_MAIN, 0) != 0;
  }
  bool stop_alt() const {
    return GetField<uint8_t>(VT_STOP_ALT, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_START_MAIN, 1) &&
           VerifyField<uint8_t>(verifier, VT_START_ALT, 1) &&
           VerifyOffset(verifier, VT_DATA_WRITE) &&
           verifier.VerifyVector(data_write()) &&
           VerifyField<uint16_t>(verifier, VT_BYTES_READ, 2) &&
           VerifyField<uint8_t>(verifier, VT_STOP_MAIN, 1) &&
           VerifyField<uint8_t>(verifier, VT_STOP_ALT, 1) &&
           verifier.EndTable();
  }
};

struct DataRequestBuilder {
  typedef DataRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_start_main(bool start_main) {
    fbb_.AddElement<uint8_t>(DataRequest::VT_START_MAIN, static_cast<uint8_t>(start_main), 0);
  }
  void add_start_alt(bool start_alt) {
    fbb_.AddElement<uint8_t>(DataRequest::VT_START_ALT, static_cast<uint8_t>(start_alt), 0);
  }
  void add_data_write(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data_write) {
    fbb_.AddOffset(DataRequest::VT_DATA_WRITE, data_write);
  }
  void add_bytes_read(uint16_t bytes_read) {
    fbb_.AddElement<uint16_t>(DataRequest::VT_BYTES_READ, bytes_read, 0);
  }
  void add_stop_main(bool stop_main) {
    fbb_.AddElement<uint8_t>(DataRequest::VT_STOP_MAIN, static_cast<uint8_t>(stop_main), 0);
  }
  void add_stop_alt(bool stop_alt) {
    fbb_.AddElement<uint8_t>(DataRequest::VT_STOP_ALT, static_cast<uint8_t>(stop_alt), 0);
  }
  explicit DataRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DataRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DataRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DataRequest> CreateDataRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool start_main = false,
    bool start_alt = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data_write = 0,
    uint16_t bytes_read = 0,
    bool stop_main = false,
    bool stop_alt = false) {
  DataRequestBuilder builder_(_fbb);
  builder_.add_data_write(data_write);
  builder_.add_bytes_read(bytes_read);
  builder_.add_stop_alt(stop_alt);
  builder_.add_stop_main(stop_main);
  builder_.add_start_alt(start_alt);
  builder_.add_start_main(start_main);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DataRequest> CreateDataRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool start_main = false,
    bool start_alt = false,
    const std::vector<uint8_t> *data_write = nullptr,
    uint16_t bytes_read = 0,
    bool stop_main = false,
    bool stop_alt = false) {
  auto data_write__ = data_write ? _fbb.CreateVector<uint8_t>(*data_write) : 0;
  return bpio::CreateDataRequest(
      _fbb,
      start_main,
      start_alt,
      data_write__,
      bytes_read,
      stop_main,
      stop_alt);
}

struct DataResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DataResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR = 4,
    VT_DATA_READ = 6
  };
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  const ::flatbuffers::Vector<uint8_t> *data_read() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA_READ);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           VerifyOffset(verifier, VT_DATA_READ) &&
           verifier.VerifyVector(data_read()) &&
           verifier.EndTable();
  }
};

struct DataResponseBuilder {
  typedef DataResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(DataResponse::VT_ERROR, error);
  }
  void add_data_read(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data_read) {
    fbb_.AddOffset(DataResponse::VT_DATA_READ, data_read);
  }
  explicit DataResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DataResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DataResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DataResponse> CreateDataResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data_read = 0) {
  DataResponseBuilder builder_(_fbb);
  builder_.add_data_read(data_read);
  builder_.add_error(error);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DataResponse> CreateDataResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *error = nullptr,
    const std::vector<uint8_t> *data_read = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  auto data_read__ = data_read ? _fbb.CreateVector<uint8_t>(*data_read) : 0;
  return bpio::CreateDataResponse(
      _fbb,
      error__,
      data_read__);
}

struct ErrorResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrorResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR = 4
  };
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
};

struct ErrorResponseBuilder {
  typedef ErrorResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(ErrorResponse::VT_ERROR, error);
  }
  explicit ErrorResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ErrorResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ErrorResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ErrorResponse> CreateErrorResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0) {
  ErrorResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ErrorResponse> CreateErrorResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *error = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return bpio::CreateErrorResponse(
      _fbb,
      error__);
}

struct RequestPacket FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestPacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION_MAJOR = 4,
    VT_VERSION_MINOR = 6,
    VT_CONTENTS_TYPE = 8,
    VT_CONTENTS = 10
  };
  uint8_t version_major() const {
    return GetField<uint8_t>(VT_VERSION_MAJOR, 0);
  }
  uint8_t version_minor() const {
    return GetField<uint8_t>(VT_VERSION_MINOR, 0);
  }
  bpio::RequestPacketContents contents_type() const {
    return static_cast<bpio::RequestPacketContents>(GetField<uint8_t>(VT_CONTENTS_TYPE, 0));
  }
  const void *contents() const {
    return GetPointer<const void *>(VT_CONTENTS);
  }
  template<typename T> const T *contents_as() const;
  const bpio::StatusRequest *contents_as_StatusRequest() const {
    return contents_type() == bpio::RequestPacketContents_StatusRequest ? static_cast<const bpio::StatusRequest *>(contents()) : nullptr;
  }
  const bpio::ConfigurationRequest *contents_as_ConfigurationRequest() const {
    return contents_type() == bpio::RequestPacketContents_ConfigurationRequest ? static_cast<const bpio::ConfigurationRequest *>(contents()) : nullptr;
  }
  const bpio::DataRequest *contents_as_DataRequest() const {
    return contents_type() == bpio::RequestPacketContents_DataRequest ? static_cast<const bpio::DataRequest *>(contents()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VERSION_MAJOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_VERSION_MINOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_CONTENTS_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONTENTS) &&
           VerifyRequestPacketContents(verifier, contents(), contents_type()) &&
           verifier.EndTable();
  }
};

template<> inline const bpio::StatusRequest *RequestPacket::contents_as<bpio::StatusRequest>() const {
  return contents_as_StatusRequest();
}

template<> inline const bpio::ConfigurationRequest *RequestPacket::contents_as<bpio::ConfigurationRequest>() const {
  return contents_as_ConfigurationRequest();
}

template<> inline const bpio::DataRequest *RequestPacket::contents_as<bpio::DataRequest>() const {
  return contents_as_DataRequest();
}

struct RequestPacketBuilder {
  typedef RequestPacket Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version_major(uint8_t version_major) {
    fbb_.AddElement<uint8_t>(RequestPacket::VT_VERSION_MAJOR, version_major, 0);
  }
  void add_version_minor(uint8_t version_minor) {
    fbb_.AddElement<uint8_t>(RequestPacket::VT_VERSION_MINOR, version_minor, 0);
  }
  void add_contents_type(bpio::RequestPacketContents contents_type) {
    fbb_.AddElement<uint8_t>(RequestPacket::VT_CONTENTS_TYPE, static_cast<uint8_t>(contents_type), 0);
  }
  void add_contents(::flatbuffers::Offset<void> contents) {
    fbb_.AddOffset(RequestPacket::VT_CONTENTS, contents);
  }
  explicit RequestPacketBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestPacket>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestPacket> CreateRequestPacket(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t version_major = 0,
    uint8_t version_minor = 0,
    bpio::RequestPacketContents contents_type = bpio::RequestPacketContents_NONE,
    ::flatbuffers::Offset<void> contents = 0) {
  RequestPacketBuilder builder_(_fbb);
  builder_.add_contents(contents);
  builder_.add_contents_type(contents_type);
  builder_.add_version_minor(version_minor);
  builder_.add_version_major(version_major);
  return builder_.Finish();
}

struct ResponsePacket FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponsePacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION_MAJOR = 4,
    VT_VERSION_MINOR = 6,
    VT_CONTENTS_TYPE = 8,
    VT_CONTENTS = 10
  };
  uint8_t version_major() const {
    return GetField<uint8_t>(VT_VERSION_MAJOR, 0);
  }
  uint8_t version_minor() const {
    return GetField<uint8_t>(VT_VERSION_MINOR, 0);
  }
  bpio::ResponsePacketContents contents_type() const {
    return static_cast<bpio::ResponsePacketContents>(GetField<uint8_t>(VT_CONTENTS_TYPE, 0));
  }
  const void *contents() const {
    return GetPointer<const void *>(VT_CONTENTS);
  }
  template<typename T> const T *contents_as() const;
  const bpio::ErrorResponse *contents_as_ErrorResponse() const {
    return contents_type() == bpio::ResponsePacketContents_ErrorResponse ? static_cast<const bpio::ErrorResponse *>(contents()) : nullptr;
  }
  const bpio::StatusResponse *contents_as_StatusResponse() const {
    return contents_type() == bpio::ResponsePacketContents_StatusResponse ? static_cast<const bpio::StatusResponse *>(contents()) : nullptr;
  }
  const bpio::ConfigurationResponse *contents_as_ConfigurationResponse() const {
    return contents_type() == bpio::ResponsePacketContents_ConfigurationResponse ? static_cast<const bpio::ConfigurationResponse *>(contents()) : nullptr;
  }
  const bpio::DataResponse *contents_as_DataResponse() const {
    return contents_type() == bpio::ResponsePacketContents_DataResponse ? static_cast<const bpio::DataResponse *>(contents()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VERSION_MAJOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_VERSION_MINOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_CONTENTS_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONTENTS) &&
           VerifyResponsePacketContents(verifier, contents(), contents_type()) &&
           verifier.EndTable();
  }
};

template<> inline const bpio::ErrorResponse *ResponsePacket::contents_as<bpio::ErrorResponse>() const {
  return contents_as_ErrorResponse();
}

template<> inline const bpio::StatusResponse *ResponsePacket::contents_as<bpio::StatusResponse>() const {
  return contents_as_StatusResponse();
}

template<> inline const bpio::ConfigurationResponse *ResponsePacket::contents_as<bpio::ConfigurationResponse>() const {
  return contents_as_ConfigurationResponse();
}

template<> inline const bpio::DataResponse *ResponsePacket::contents_as<bpio::DataResponse>() const {
  return contents_as_DataResponse();
}

struct ResponsePacketBuilder {
  typedef ResponsePacket Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version_major(uint8_t version_major) {
    fbb_.AddElement<uint8_t>(ResponsePacket::VT_VERSION_MAJOR, version_major, 0);
  }
  void add_version_minor(uint8_t version_minor) {
    fbb_.AddElement<uint8_t>(ResponsePacket::VT_VERSION_MINOR, version_minor, 0);
  }
  void add_contents_type(bpio::ResponsePacketContents contents_type) {
    fbb_.AddElement<uint8_t>(ResponsePacket::VT_CONTENTS_TYPE, static_cast<uint8_t>(contents_type), 0);
  }
  void add_contents(::flatbuffers::Offset<void> contents) {
    fbb_.AddOffset(ResponsePacket::VT_CONTENTS, contents);
  }
  explicit ResponsePacketBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponsePacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponsePacket>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponsePacket> CreateResponsePacket(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t version_major = 0,
    uint8_t version_minor = 0,
    bpio::ResponsePacketContents contents_type = bpio::ResponsePacketContents_NONE,
    ::flatbuffers::Offset<void> contents = 0) {
  ResponsePacketBuilder builder_(_fbb);
  builder_.add_contents(contents);
  builder_.add_contents_type(contents_type);
  builder_.add_version_minor(version_minor);
  builder_.add_version_major(version_major);
  return builder_.Finish();
}

inline bool VerifyRequestPacketContents(::flatbuffers::Verifier &verifier, const void *obj, RequestPacketContents type) {
  switch (type) {
    case RequestPacketContents_NONE: {
      return true;
    }
    case RequestPacketContents_StatusRequest: {
      auto ptr = reinterpret_cast<const bpio::StatusRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPacketContents_ConfigurationRequest: {
      auto ptr = reinterpret_cast<const bpio::ConfigurationRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPacketContents_DataRequest: {
      auto ptr = reinterpret_cast<const bpio::DataRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRequestPacketContentsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRequestPacketContents(
        verifier,  values->Get(i), types->GetEnum<RequestPacketContents>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyResponsePacketContents(::flatbuffers::Verifier &verifier, const void *obj, ResponsePacketContents type) {
  switch (type) {
    case ResponsePacketContents_NONE: {
      return true;
    }
    case ResponsePacketContents_ErrorResponse: {
      auto ptr = reinterpret_cast<const bpio::ErrorResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePacketContents_StatusResponse: {
      auto ptr = reinterpret_cast<const bpio::StatusResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePacketContents_ConfigurationResponse: {
      auto ptr = reinterpret_cast<const bpio::ConfigurationResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePacketContents_DataResponse: {
      auto ptr = reinterpret_cast<const bpio::DataResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyResponsePacketContentsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResponsePacketContents(
        verifier,  values->Get(i), types->GetEnum<ResponsePacketContents>(i))) {
      return false;
    }
  }
  return true;
}

inline const bpio::ResponsePacket *GetResponsePacket(const void *buf) {
  return ::flatbuffers::GetRoot<bpio::ResponsePacket>(buf);
}

inline const bpio::ResponsePacket *GetSizePrefixedResponsePacket(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<bpio::ResponsePacket>(buf);
}

inline bool VerifyResponsePacketBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<bpio::ResponsePacket>(nullptr);
}

inline bool VerifySizePrefixedResponsePacketBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<bpio::ResponsePacket>(nullptr);
}

inline void FinishResponsePacketBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<bpio::ResponsePacket> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedResponsePacketBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<bpio::ResponsePacket> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace bpio

#endif  // FLATBUFFERS_GENERATED_BPIO_BPIO_H_
